// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CapabilitiesType {
    /// In a system with the \[_POSIX_CHOWN_RESTRICTED\] option defined, this
    /// overrides the restriction of changing file ownership and group
    /// ownership.
    CapChown = 0,
    /// Override all DAC access, including ACL execute access if
    /// \[_POSIX_ACL\] is defined. Excluding DAC access covered by
    /// CAP_LINUX_IMMUTABLE.
    DacOverride = 1,
    /// Overrides all DAC restrictions regarding read and search on files
    /// and directories, including ACL restrictions if \[_POSIX_ACL\] is
    /// defined. Excluding DAC access covered by "$1"_LINUX_IMMUTABLE.
    CapDacReadSearch = 2,
    /// Overrides all restrictions about allowed operations on files, where
    /// file owner ID must be equal to the user ID, except where CAP_FSETID
    /// is applicable. It doesn't override MAC and DAC restrictions.
    CapFowner = 3,
    /// Overrides the following restrictions that the effective user ID
    /// shall match the file owner ID when setting the S_ISUID and S_ISGID
    /// bits on that file; that the effective group ID (or one of the
    /// supplementary group IDs) shall match the file owner ID when setting
    /// the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
    /// cleared on successful return from chown(2) (not implemented).
    CapFsetid = 4,
    /// Overrides the restriction that the real or effective user ID of a
    /// process sending a signal must match the real or effective user ID
    /// of the process receiving the signal.
    CapKill = 5,
    /// Allows forged gids on socket credentials passing.
    CapSetgid = 6,
    /// Allows forged pids on socket credentials passing.
    CapSetuid = 7,
    /// Without VFS support for capabilities:
    ///    Transfer any capability in your permitted set to any pid,
    ///    remove any capability in your permitted set from any pid
    /// With VFS support for capabilities (neither of above, but)
    ///    Add any capability from current's capability bounding set
    ///        to the current process' inheritable set
    ///    Allow taking bits out of capability bounding set
    ///    Allow modification of the securebits for a process
    CapSetpcap = 8,
    /// Allow modification of S_IMMUTABLE and S_APPEND file attributes
    CapLinuxImmutable = 9,
    /// Allows binding to ATM VCIs below 32
    CapNetBindService = 10,
    /// Allow broadcasting, listen to multicast
    CapNetBroadcast = 11,
    /// Allow activation of ATM control sockets
    CapNetAdmin = 12,
    /// Allow binding to any address for transparent proxying (also via NET_ADMIN)
    CapNetRaw = 13,
    /// Allow mlock and mlockall (which doesn't really have anything to do
    /// with IPC)
    CapIpcLock = 14,
    /// Override IPC ownership checks
    CapIpcOwner = 15,
    /// Insert and remove kernel modules - modify kernel without limit
    CapSysModule = 16,
    /// Allow sending USB messages to any device via /dev/bus/usb
    CapSysRawio = 17,
    /// Allow use of chroot()
    CapSysChroot = 18,
    /// Allow ptrace() of any process
    CapSysPtrace = 19,
    /// Allow configuration of process accounting
    CapSysPacct = 20,
    /// Allow everything under CAP_BPF and CAP_PERFMON for backward compatibility
    CapSysAdmin = 21,
    /// Allow use of reboot()
    CapSysBoot = 22,
    /// Allow setting cpu affinity on other processes
    CapSysNice = 23,
    /// Control memory reclaim behavior
    CapSysResource = 24,
    /// Allow setting the real-time clock
    CapSysTime = 25,
    /// Allow vhangup() of tty
    CapSysTtyConfig = 26,
    /// Allow the privileged aspects of mknod()
    CapMknod = 27,
    /// Allow taking of leases on files
    CapLease = 28,
    /// Allow writing the audit log via unicast netlink socket
    CapAuditWrite = 29,
    /// Allow configuration of audit via unicast netlink socket
    CapAuditControl = 30,
    /// Set or remove capabilities on files
    CapSetfcap = 31,
    /// Override MAC access.
    /// The base kernel enforces no MAC policy.
    /// An LSM may enforce a MAC policy, and if it does and it chooses
    /// to implement capability based overrides of that policy, this is
    /// the capability it should use to do so.
    CapMacOverride = 32,
    /// Allow MAC configuration or state changes.
    /// The base kernel requires no MAC configuration.
    /// An LSM may enforce a MAC policy, and if it does and it chooses
    /// to implement capability based checks on modifications to that
    /// policy or the data required to maintain it, this is the
    /// capability it should use to do so.
    CapMacAdmin = 33,
    /// Allow configuring the kernel's syslog (printk behaviour)
    CapSyslog = 34,
    /// Allow triggering something that will wake the system
    CapWakeAlarm = 35,
    /// Allow preventing system suspends
    CapBlockSuspend = 36,
    /// Allow reading the audit log via multicast netlink socket
    CapAuditRead = 37,
    ///
    /// Allow system performance and observability privileged operations
    /// using perf_events, i915_perf and other kernel subsystems
    CapPerfmon = 38,
    ///
    /// CAP_BPF allows the following BPF operations:
    /// - Creating all types of BPF maps
    /// - Advanced verifier features
    ///    - Indirect variable access
    ///    - Bounded loops
    ///    - BPF to BPF function calls
    ///    - Scalar precision tracking
    ///    - Larger complexity limits
    ///    - Dead code elimination
    ///    - And potentially other features
    /// - Loading BPF Type Format (BTF) data
    /// - Retrieve xlated and JITed code of BPF programs
    /// - Use bpf_spin_lock() helper
    /// CAP_PERFMON relaxes the verifier checks further:
    /// - BPF progs can use of pointer-to-integer conversions
    /// - speculation attack hardening measures are bypassed
    /// - bpf_probe_read to read arbitrary kernel memory is allowed
    /// - bpf_trace_printk to print kernel memory is allowed
    /// CAP_SYS_ADMIN is required to use bpf_probe_write_user.
    /// CAP_SYS_ADMIN is required to iterate system wide loaded
    /// programs, maps, links, BTFs and convert their IDs to file descriptors.
    /// CAP_PERFMON and CAP_BPF are required to load tracing programs.
    /// CAP_NET_ADMIN and CAP_BPF are required to load networking programs.
    CapBpf = 39,
    /// Allow writing to ns_last_pid
    CapCheckpointRestore = 40,
}
impl CapabilitiesType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CapChown => "CAP_CHOWN",
            Self::DacOverride => "DAC_OVERRIDE",
            Self::CapDacReadSearch => "CAP_DAC_READ_SEARCH",
            Self::CapFowner => "CAP_FOWNER",
            Self::CapFsetid => "CAP_FSETID",
            Self::CapKill => "CAP_KILL",
            Self::CapSetgid => "CAP_SETGID",
            Self::CapSetuid => "CAP_SETUID",
            Self::CapSetpcap => "CAP_SETPCAP",
            Self::CapLinuxImmutable => "CAP_LINUX_IMMUTABLE",
            Self::CapNetBindService => "CAP_NET_BIND_SERVICE",
            Self::CapNetBroadcast => "CAP_NET_BROADCAST",
            Self::CapNetAdmin => "CAP_NET_ADMIN",
            Self::CapNetRaw => "CAP_NET_RAW",
            Self::CapIpcLock => "CAP_IPC_LOCK",
            Self::CapIpcOwner => "CAP_IPC_OWNER",
            Self::CapSysModule => "CAP_SYS_MODULE",
            Self::CapSysRawio => "CAP_SYS_RAWIO",
            Self::CapSysChroot => "CAP_SYS_CHROOT",
            Self::CapSysPtrace => "CAP_SYS_PTRACE",
            Self::CapSysPacct => "CAP_SYS_PACCT",
            Self::CapSysAdmin => "CAP_SYS_ADMIN",
            Self::CapSysBoot => "CAP_SYS_BOOT",
            Self::CapSysNice => "CAP_SYS_NICE",
            Self::CapSysResource => "CAP_SYS_RESOURCE",
            Self::CapSysTime => "CAP_SYS_TIME",
            Self::CapSysTtyConfig => "CAP_SYS_TTY_CONFIG",
            Self::CapMknod => "CAP_MKNOD",
            Self::CapLease => "CAP_LEASE",
            Self::CapAuditWrite => "CAP_AUDIT_WRITE",
            Self::CapAuditControl => "CAP_AUDIT_CONTROL",
            Self::CapSetfcap => "CAP_SETFCAP",
            Self::CapMacOverride => "CAP_MAC_OVERRIDE",
            Self::CapMacAdmin => "CAP_MAC_ADMIN",
            Self::CapSyslog => "CAP_SYSLOG",
            Self::CapWakeAlarm => "CAP_WAKE_ALARM",
            Self::CapBlockSuspend => "CAP_BLOCK_SUSPEND",
            Self::CapAuditRead => "CAP_AUDIT_READ",
            Self::CapPerfmon => "CAP_PERFMON",
            Self::CapBpf => "CAP_BPF",
            Self::CapCheckpointRestore => "CAP_CHECKPOINT_RESTORE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAP_CHOWN" => Some(Self::CapChown),
            "DAC_OVERRIDE" => Some(Self::DacOverride),
            "CAP_DAC_READ_SEARCH" => Some(Self::CapDacReadSearch),
            "CAP_FOWNER" => Some(Self::CapFowner),
            "CAP_FSETID" => Some(Self::CapFsetid),
            "CAP_KILL" => Some(Self::CapKill),
            "CAP_SETGID" => Some(Self::CapSetgid),
            "CAP_SETUID" => Some(Self::CapSetuid),
            "CAP_SETPCAP" => Some(Self::CapSetpcap),
            "CAP_LINUX_IMMUTABLE" => Some(Self::CapLinuxImmutable),
            "CAP_NET_BIND_SERVICE" => Some(Self::CapNetBindService),
            "CAP_NET_BROADCAST" => Some(Self::CapNetBroadcast),
            "CAP_NET_ADMIN" => Some(Self::CapNetAdmin),
            "CAP_NET_RAW" => Some(Self::CapNetRaw),
            "CAP_IPC_LOCK" => Some(Self::CapIpcLock),
            "CAP_IPC_OWNER" => Some(Self::CapIpcOwner),
            "CAP_SYS_MODULE" => Some(Self::CapSysModule),
            "CAP_SYS_RAWIO" => Some(Self::CapSysRawio),
            "CAP_SYS_CHROOT" => Some(Self::CapSysChroot),
            "CAP_SYS_PTRACE" => Some(Self::CapSysPtrace),
            "CAP_SYS_PACCT" => Some(Self::CapSysPacct),
            "CAP_SYS_ADMIN" => Some(Self::CapSysAdmin),
            "CAP_SYS_BOOT" => Some(Self::CapSysBoot),
            "CAP_SYS_NICE" => Some(Self::CapSysNice),
            "CAP_SYS_RESOURCE" => Some(Self::CapSysResource),
            "CAP_SYS_TIME" => Some(Self::CapSysTime),
            "CAP_SYS_TTY_CONFIG" => Some(Self::CapSysTtyConfig),
            "CAP_MKNOD" => Some(Self::CapMknod),
            "CAP_LEASE" => Some(Self::CapLease),
            "CAP_AUDIT_WRITE" => Some(Self::CapAuditWrite),
            "CAP_AUDIT_CONTROL" => Some(Self::CapAuditControl),
            "CAP_SETFCAP" => Some(Self::CapSetfcap),
            "CAP_MAC_OVERRIDE" => Some(Self::CapMacOverride),
            "CAP_MAC_ADMIN" => Some(Self::CapMacAdmin),
            "CAP_SYSLOG" => Some(Self::CapSyslog),
            "CAP_WAKE_ALARM" => Some(Self::CapWakeAlarm),
            "CAP_BLOCK_SUSPEND" => Some(Self::CapBlockSuspend),
            "CAP_AUDIT_READ" => Some(Self::CapAuditRead),
            "CAP_PERFMON" => Some(Self::CapPerfmon),
            "CAP_BPF" => Some(Self::CapBpf),
            "CAP_CHECKPOINT_RESTORE" => Some(Self::CapCheckpointRestore),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SecureBitsType {
    SecBitNotSet = 0,
    /// When set UID 0 has no special privileges. When unset, inheritance
    /// of root-permissions and suid-root executable under compatibility mode
    /// is supported. If the effective uid of the new process is 0 then
    /// the effective and inheritable bitmasks of the executable file is raised.
    /// If the real uid is 0, the effective (legacy) bit of the executable file
    /// is raised.
    SecBitNoRoot = 1,
    /// Make bit-0 SecBitNoRoot immutable
    SecBitNoRootLocked = 2,
    /// When set, setuid to/from uid 0 does not trigger capability-"fixup".
    /// When unset, to provide compatiblility with old programs relying on
    /// set*uid to gain/lose privilege, transitions to/from uid 0 cause
    /// capabilities to be gained/lost.
    SecBitNoSetUidFixup = 4,
    /// Make bit-2 SecBitNoSetUidFixup immutable
    SecBitNoSetUidFixupLocked = 8,
    /// When set, a process can retain its capabilities even after
    /// transitioning to a non-root user (the set-uid fixup suppressed by
    /// bit 2). Bit-4 is cleared when a process calls exec(); setting both
    /// bit 4 and 5 will create a barrier through exec that no exec()'d
    /// child can use this feature again.
    SecBitKeepCaps = 16,
    /// Make bit-4 SecBitKeepCaps immutable
    SecBitKeepCapsLocked = 32,
    /// When set, a process cannot add new capabilities to its ambient set.
    SecBitNoCapAmbientRaise = 64,
    /// Make bit-6 SecBitNoCapAmbientRaise immutable
    SecBitNoCapAmbientRaiseLocked = 128,
}
impl SecureBitsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SecBitNotSet => "SecBitNotSet",
            Self::SecBitNoRoot => "SecBitNoRoot",
            Self::SecBitNoRootLocked => "SecBitNoRootLocked",
            Self::SecBitNoSetUidFixup => "SecBitNoSetUidFixup",
            Self::SecBitNoSetUidFixupLocked => "SecBitNoSetUidFixupLocked",
            Self::SecBitKeepCaps => "SecBitKeepCaps",
            Self::SecBitKeepCapsLocked => "SecBitKeepCapsLocked",
            Self::SecBitNoCapAmbientRaise => "SecBitNoCapAmbientRaise",
            Self::SecBitNoCapAmbientRaiseLocked => "SecBitNoCapAmbientRaiseLocked",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SecBitNotSet" => Some(Self::SecBitNotSet),
            "SecBitNoRoot" => Some(Self::SecBitNoRoot),
            "SecBitNoRootLocked" => Some(Self::SecBitNoRootLocked),
            "SecBitNoSetUidFixup" => Some(Self::SecBitNoSetUidFixup),
            "SecBitNoSetUidFixupLocked" => Some(Self::SecBitNoSetUidFixupLocked),
            "SecBitKeepCaps" => Some(Self::SecBitKeepCaps),
            "SecBitKeepCapsLocked" => Some(Self::SecBitKeepCapsLocked),
            "SecBitNoCapAmbientRaise" => Some(Self::SecBitNoCapAmbientRaise),
            "SecBitNoCapAmbientRaiseLocked" => Some(Self::SecBitNoCapAmbientRaiseLocked),
            _ => None,
        }
    }
}
/// Reasons of why the process privileges changed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessPrivilegesChanged {
    PrivilegesChangedUnset = 0,
    /// A privilege elevation happened due to the execution of a binary with file capability sets.
    /// The kernel supports associating capability sets with an executable file using `setcap` command.
    /// The file capability sets are stored in an extended attribute (see <https://man7.org/linux/man-pages/man7/xattr.7.html>)
    /// named `security.capability`. The file capability sets, in conjunction with the capability sets
    /// of the process, determine the process capabilities and privileges after the `execve` system call.
    /// For further reference, please check sections `File capability extended attribute versioning` and
    /// `Namespaced file capabilities` of the capabilities man pages: <https://man7.org/linux/man-pages/man7/capabilities.7.html.>
    /// The new granted capabilities can be listed inside the `process` object.
    PrivilegesRaisedExecFileCap = 1,
    /// A privilege elevation happened due to the execution of a binary with set-user-ID to root.
    /// When a process with nonzero UIDs executes a binary with a set-user-ID to root also
    /// known as suid-root executable, then the kernel switches the effective user ID to 0 (root) which
    /// is a privilege elevation operation since it grants access to resources owned by the root user.
    /// The effective user ID is listed inside the `process_credentials` part of the `process` object.
    /// For further reading, section `Capabilities and execution of programs by root` of <https://man7.org/linux/man-pages/man7/capabilities.7.html.>
    /// Afterward the kernel recalculates the capability sets of the process and grants all capabilities
    /// in the permitted and effective capability sets, except those masked out by the capability bounding set.
    /// If the binary also have file capability sets then these bits are honored and the process gains just
    /// the capabilities granted by the file capability sets (i.e., not all capabilities, as it would occur
    /// when executing a set-user-ID to root binary that does not have any associated file capabilities). This
    /// is described in section `Set-user-ID-root programs that have file capabilities` of <https://man7.org/linux/man-pages/man7/capabilities.7.html.>
    /// The new granted capabilities can be listed inside the `process` object.
    /// There is one exception for the special treatments of set-user-ID to root execution receiving all
    /// capabilities, if the `SecBitNoRoot` bit of the Secure bits is set, then the kernel does not grant
    /// any capability. Please check section: `The securebits flags: establishing a capabilities-only environment`
    /// of the capabilities man pages: <https://man7.org/linux/man-pages/man7/capabilities.7.html>
    PrivilegesRaisedExecFileSetuid = 2,
    /// A privilege elevation happened due to the execution of a binary with set-group-ID to root.
    /// When a process with nonzero GIDs executes a binary with a set-group-ID to root, the kernel switches
    /// the effective group ID to 0 (root) which is a privilege elevation operation since it grants access to
    /// resources owned by the root group.
    /// The effective group ID is listed inside the `process_credentials` part of the `process` object.
    PrivilegesRaisedExecFileSetgid = 3,
}
impl ProcessPrivilegesChanged {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PrivilegesChangedUnset => "PRIVILEGES_CHANGED_UNSET",
            Self::PrivilegesRaisedExecFileCap => "PRIVILEGES_RAISED_EXEC_FILE_CAP",
            Self::PrivilegesRaisedExecFileSetuid => "PRIVILEGES_RAISED_EXEC_FILE_SETUID",
            Self::PrivilegesRaisedExecFileSetgid => "PRIVILEGES_RAISED_EXEC_FILE_SETGID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRIVILEGES_CHANGED_UNSET" => Some(Self::PrivilegesChangedUnset),
            "PRIVILEGES_RAISED_EXEC_FILE_CAP" => Some(Self::PrivilegesRaisedExecFileCap),
            "PRIVILEGES_RAISED_EXEC_FILE_SETUID" => {
                Some(Self::PrivilegesRaisedExecFileSetuid)
            }
            "PRIVILEGES_RAISED_EXEC_FILE_SETGID" => {
                Some(Self::PrivilegesRaisedExecFileSetgid)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BpfCmd {
    /// Create a map and return a file descriptor that refers to the
    /// map.
    BpfMapCreate = 0,
    /// Look up an element with a given key in the map referred to
    /// by the file descriptor map_fd.
    BpfMapLookupElem = 1,
    /// Create or update an element (key/value pair) in a specified map.
    BpfMapUpdateElem = 2,
    /// Look up and delete an element by key in a specified map.
    BpfMapDeleteElem = 3,
    /// Look up an element by key in a specified map and return the key
    /// of the next element. Can be used to iterate over all elements
    /// in the map.
    BpfMapGetNextKey = 4,
    /// Verify and load an eBPF program, returning a new file descriptor
    /// associated with the program.
    BpfProgLoad = 5,
    /// Pin an eBPF program or map referred by the specified bpf_fd
    /// to the provided pathname on the filesystem.
    BpfObjPin = 6,
    /// Open a file descriptor for the eBPF object pinned to the
    /// specified pathname.
    BpfObjGet = 7,
    /// Attach an eBPF program to a target_fd at the specified
    /// attach_type hook.
    BpfProgAttach = 8,
    /// Detach the eBPF program associated with the target_fd at the
    /// hook specified by attach_type.
    BpfProgDetach = 9,
    /// Run the eBPF program associated with the prog_fd a repeat
    /// number of times against a provided program context ctx_in and
    /// data data_in, and return the modified program context
    /// ctx_out, data_out (for example, packet data), result of the
    /// execution retval, and duration of the test run.
    BpfProgTestRun = 10,
    /// Fetch the next eBPF program currently loaded into the kernel.
    BpfProgGetNextId = 11,
    /// Fetch the next eBPF map currently loaded into the kernel.
    BpfMapGetNextId = 12,
    /// Open a file descriptor for the eBPF program corresponding to prog_id.
    BpfProgGetFdById = 13,
    /// Open a file descriptor for the eBPF map corresponding to map_id.
    BpfMapGetFdById = 14,
    /// Obtain information about the eBPF object corresponding to bpf_fd.
    BpfObjGetInfoByFd = 15,
    /// Obtain information about eBPF programs associated with the specified
    /// attach_type hook.
    BpfProgQuery = 16,
    /// Attach an eBPF program to a tracepoint *name* to access kernel
    /// internal arguments of the tracepoint in their raw form.
    BpfRawTracepointOpen = 17,
    /// Verify and load BPF Type Format (BTF) metadata into the kernel,
    /// returning a new file descriptor associated with the metadata.
    BpfBtfLoad = 18,
    /// Open a file descriptor for the BPF Type Format (BTF)
    /// corresponding to btf_id.
    BpfBtfGetFdById = 19,
    /// Obtain information about eBPF programs associated with the target
    /// process identified by pid and fd.
    BpfTaskFdQuery = 20,
    /// Look up an element with the given key in the map referred to
    /// by the file descriptor fd, and if found, delete the element.
    BpfMapLookupAndDeleteElem = 21,
    /// Freeze the permissions of the specified map.
    BpfMapFreeze = 22,
    /// Fetch the next BPF Type Format (BTF) object currently loaded into
    /// the kernel.
    BpfBtfGetNextId = 23,
    /// Iterate and fetch multiple elements in a map.
    BpfMapLookupBatch = 24,
    /// Iterate and delete all elements in a map.
    BpfMapLookupAndDeleteBatch = 25,
    /// Update multiple elements in a map by key.
    BpfMapUpdateBatch = 26,
    /// Delete multiple elements in a map by key.
    BpfMapDeleteBatch = 27,
    /// Attach an eBPF program to a target_fd at the specified
    /// attach_type hook and return a file descriptor handle for
    /// managing the link.
    BpfLinkCreate = 28,
    /// Update the eBPF program in the specified link_fd to
    /// new_prog_fd.
    BpfLinkUpdate = 29,
    /// Open a file descriptor for the eBPF Link corresponding to
    /// link_id.
    BpfLinkGetFdById = 30,
    /// Fetch the next eBPF link currently loaded into the kernel.
    BpfLinkGetNextId = 31,
    /// Enable eBPF runtime statistics gathering.
    BpfEnableStats = 32,
    /// Create an iterator on top of the specified link_fd (as
    /// previously created using BPF_LINK_CREATE) and return a
    /// file descriptor that can be used to trigger the iteration.
    BpfIterCreate = 33,
    /// Forcefully detach the specified link_fd from its corresponding
    /// attachment point.
    BpfLinkDetach = 34,
    /// Bind a map to the lifetime of an eBPF program.
    BpfProgBindMap = 35,
    /// Create BPF token with embedded information about what can be
    /// passed as an extra parameter to various bpf() syscall commands
    /// to grant BPF subsystem functionality to unprivileged processes.
    BpfTokenCreate = 36,
}
impl BpfCmd {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BpfMapCreate => "BPF_MAP_CREATE",
            Self::BpfMapLookupElem => "BPF_MAP_LOOKUP_ELEM",
            Self::BpfMapUpdateElem => "BPF_MAP_UPDATE_ELEM",
            Self::BpfMapDeleteElem => "BPF_MAP_DELETE_ELEM",
            Self::BpfMapGetNextKey => "BPF_MAP_GET_NEXT_KEY",
            Self::BpfProgLoad => "BPF_PROG_LOAD",
            Self::BpfObjPin => "BPF_OBJ_PIN",
            Self::BpfObjGet => "BPF_OBJ_GET",
            Self::BpfProgAttach => "BPF_PROG_ATTACH",
            Self::BpfProgDetach => "BPF_PROG_DETACH",
            Self::BpfProgTestRun => "BPF_PROG_TEST_RUN",
            Self::BpfProgGetNextId => "BPF_PROG_GET_NEXT_ID",
            Self::BpfMapGetNextId => "BPF_MAP_GET_NEXT_ID",
            Self::BpfProgGetFdById => "BPF_PROG_GET_FD_BY_ID",
            Self::BpfMapGetFdById => "BPF_MAP_GET_FD_BY_ID",
            Self::BpfObjGetInfoByFd => "BPF_OBJ_GET_INFO_BY_FD",
            Self::BpfProgQuery => "BPF_PROG_QUERY",
            Self::BpfRawTracepointOpen => "BPF_RAW_TRACEPOINT_OPEN",
            Self::BpfBtfLoad => "BPF_BTF_LOAD",
            Self::BpfBtfGetFdById => "BPF_BTF_GET_FD_BY_ID",
            Self::BpfTaskFdQuery => "BPF_TASK_FD_QUERY",
            Self::BpfMapLookupAndDeleteElem => "BPF_MAP_LOOKUP_AND_DELETE_ELEM",
            Self::BpfMapFreeze => "BPF_MAP_FREEZE",
            Self::BpfBtfGetNextId => "BPF_BTF_GET_NEXT_ID",
            Self::BpfMapLookupBatch => "BPF_MAP_LOOKUP_BATCH",
            Self::BpfMapLookupAndDeleteBatch => "BPF_MAP_LOOKUP_AND_DELETE_BATCH",
            Self::BpfMapUpdateBatch => "BPF_MAP_UPDATE_BATCH",
            Self::BpfMapDeleteBatch => "BPF_MAP_DELETE_BATCH",
            Self::BpfLinkCreate => "BPF_LINK_CREATE",
            Self::BpfLinkUpdate => "BPF_LINK_UPDATE",
            Self::BpfLinkGetFdById => "BPF_LINK_GET_FD_BY_ID",
            Self::BpfLinkGetNextId => "BPF_LINK_GET_NEXT_ID",
            Self::BpfEnableStats => "BPF_ENABLE_STATS",
            Self::BpfIterCreate => "BPF_ITER_CREATE",
            Self::BpfLinkDetach => "BPF_LINK_DETACH",
            Self::BpfProgBindMap => "BPF_PROG_BIND_MAP",
            Self::BpfTokenCreate => "BPF_TOKEN_CREATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BPF_MAP_CREATE" => Some(Self::BpfMapCreate),
            "BPF_MAP_LOOKUP_ELEM" => Some(Self::BpfMapLookupElem),
            "BPF_MAP_UPDATE_ELEM" => Some(Self::BpfMapUpdateElem),
            "BPF_MAP_DELETE_ELEM" => Some(Self::BpfMapDeleteElem),
            "BPF_MAP_GET_NEXT_KEY" => Some(Self::BpfMapGetNextKey),
            "BPF_PROG_LOAD" => Some(Self::BpfProgLoad),
            "BPF_OBJ_PIN" => Some(Self::BpfObjPin),
            "BPF_OBJ_GET" => Some(Self::BpfObjGet),
            "BPF_PROG_ATTACH" => Some(Self::BpfProgAttach),
            "BPF_PROG_DETACH" => Some(Self::BpfProgDetach),
            "BPF_PROG_TEST_RUN" => Some(Self::BpfProgTestRun),
            "BPF_PROG_GET_NEXT_ID" => Some(Self::BpfProgGetNextId),
            "BPF_MAP_GET_NEXT_ID" => Some(Self::BpfMapGetNextId),
            "BPF_PROG_GET_FD_BY_ID" => Some(Self::BpfProgGetFdById),
            "BPF_MAP_GET_FD_BY_ID" => Some(Self::BpfMapGetFdById),
            "BPF_OBJ_GET_INFO_BY_FD" => Some(Self::BpfObjGetInfoByFd),
            "BPF_PROG_QUERY" => Some(Self::BpfProgQuery),
            "BPF_RAW_TRACEPOINT_OPEN" => Some(Self::BpfRawTracepointOpen),
            "BPF_BTF_LOAD" => Some(Self::BpfBtfLoad),
            "BPF_BTF_GET_FD_BY_ID" => Some(Self::BpfBtfGetFdById),
            "BPF_TASK_FD_QUERY" => Some(Self::BpfTaskFdQuery),
            "BPF_MAP_LOOKUP_AND_DELETE_ELEM" => Some(Self::BpfMapLookupAndDeleteElem),
            "BPF_MAP_FREEZE" => Some(Self::BpfMapFreeze),
            "BPF_BTF_GET_NEXT_ID" => Some(Self::BpfBtfGetNextId),
            "BPF_MAP_LOOKUP_BATCH" => Some(Self::BpfMapLookupBatch),
            "BPF_MAP_LOOKUP_AND_DELETE_BATCH" => Some(Self::BpfMapLookupAndDeleteBatch),
            "BPF_MAP_UPDATE_BATCH" => Some(Self::BpfMapUpdateBatch),
            "BPF_MAP_DELETE_BATCH" => Some(Self::BpfMapDeleteBatch),
            "BPF_LINK_CREATE" => Some(Self::BpfLinkCreate),
            "BPF_LINK_UPDATE" => Some(Self::BpfLinkUpdate),
            "BPF_LINK_GET_FD_BY_ID" => Some(Self::BpfLinkGetFdById),
            "BPF_LINK_GET_NEXT_ID" => Some(Self::BpfLinkGetNextId),
            "BPF_ENABLE_STATS" => Some(Self::BpfEnableStats),
            "BPF_ITER_CREATE" => Some(Self::BpfIterCreate),
            "BPF_LINK_DETACH" => Some(Self::BpfLinkDetach),
            "BPF_PROG_BIND_MAP" => Some(Self::BpfProgBindMap),
            "BPF_TOKEN_CREATE" => Some(Self::BpfTokenCreate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BpfProgramType {
    BpfProgTypeUnspec = 0,
    BpfProgTypeSocketFilter = 1,
    BpfProgTypeKprobe = 2,
    BpfProgTypeSchedCls = 3,
    BpfProgTypeSchedAct = 4,
    BpfProgTypeTracepoint = 5,
    BpfProgTypeXdp = 6,
    BpfProgTypePerfEvent = 7,
    BpfProgTypeCgroupSkb = 8,
    BpfProgTypeCgroupSock = 9,
    BpfProgTypeLwtIn = 10,
    BpfProgTypeLwtOut = 11,
    BpfProgTypeLwtXmit = 12,
    BpfProgTypeSockOps = 13,
    BpfProgTypeSkSkb = 14,
    BpfProgTypeCgroupDevice = 15,
    BpfProgTypeSkMsg = 16,
    BpfProgTypeRawTracepoint = 17,
    BpfProgTypeCgroupSockAddr = 18,
    BpfProgTypeLwtSeg6local = 19,
    BpfProgTypeLircMode2 = 20,
    BpfProgTypeSkReuseport = 21,
    BpfProgTypeFlowDissector = 22,
    BpfProgTypeCgroupSysctl = 23,
    BpfProgTypeRawTracepointWritable = 24,
    BpfProgTypeCgroupSockopt = 25,
    BpfProgTypeTracing = 26,
    BpfProgTypeStructOps = 27,
    BpfProgTypeExt = 28,
    BpfProgTypeLsm = 29,
    BpfProgTypeSkLookup = 30,
    BpfProgTypeSyscall = 31,
    BpfProgTypeNetfilter = 32,
}
impl BpfProgramType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BpfProgTypeUnspec => "BPF_PROG_TYPE_UNSPEC",
            Self::BpfProgTypeSocketFilter => "BPF_PROG_TYPE_SOCKET_FILTER",
            Self::BpfProgTypeKprobe => "BPF_PROG_TYPE_KPROBE",
            Self::BpfProgTypeSchedCls => "BPF_PROG_TYPE_SCHED_CLS",
            Self::BpfProgTypeSchedAct => "BPF_PROG_TYPE_SCHED_ACT",
            Self::BpfProgTypeTracepoint => "BPF_PROG_TYPE_TRACEPOINT",
            Self::BpfProgTypeXdp => "BPF_PROG_TYPE_XDP",
            Self::BpfProgTypePerfEvent => "BPF_PROG_TYPE_PERF_EVENT",
            Self::BpfProgTypeCgroupSkb => "BPF_PROG_TYPE_CGROUP_SKB",
            Self::BpfProgTypeCgroupSock => "BPF_PROG_TYPE_CGROUP_SOCK",
            Self::BpfProgTypeLwtIn => "BPF_PROG_TYPE_LWT_IN",
            Self::BpfProgTypeLwtOut => "BPF_PROG_TYPE_LWT_OUT",
            Self::BpfProgTypeLwtXmit => "BPF_PROG_TYPE_LWT_XMIT",
            Self::BpfProgTypeSockOps => "BPF_PROG_TYPE_SOCK_OPS",
            Self::BpfProgTypeSkSkb => "BPF_PROG_TYPE_SK_SKB",
            Self::BpfProgTypeCgroupDevice => "BPF_PROG_TYPE_CGROUP_DEVICE",
            Self::BpfProgTypeSkMsg => "BPF_PROG_TYPE_SK_MSG",
            Self::BpfProgTypeRawTracepoint => "BPF_PROG_TYPE_RAW_TRACEPOINT",
            Self::BpfProgTypeCgroupSockAddr => "BPF_PROG_TYPE_CGROUP_SOCK_ADDR",
            Self::BpfProgTypeLwtSeg6local => "BPF_PROG_TYPE_LWT_SEG6LOCAL",
            Self::BpfProgTypeLircMode2 => "BPF_PROG_TYPE_LIRC_MODE2",
            Self::BpfProgTypeSkReuseport => "BPF_PROG_TYPE_SK_REUSEPORT",
            Self::BpfProgTypeFlowDissector => "BPF_PROG_TYPE_FLOW_DISSECTOR",
            Self::BpfProgTypeCgroupSysctl => "BPF_PROG_TYPE_CGROUP_SYSCTL",
            Self::BpfProgTypeRawTracepointWritable => {
                "BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE"
            }
            Self::BpfProgTypeCgroupSockopt => "BPF_PROG_TYPE_CGROUP_SOCKOPT",
            Self::BpfProgTypeTracing => "BPF_PROG_TYPE_TRACING",
            Self::BpfProgTypeStructOps => "BPF_PROG_TYPE_STRUCT_OPS",
            Self::BpfProgTypeExt => "BPF_PROG_TYPE_EXT",
            Self::BpfProgTypeLsm => "BPF_PROG_TYPE_LSM",
            Self::BpfProgTypeSkLookup => "BPF_PROG_TYPE_SK_LOOKUP",
            Self::BpfProgTypeSyscall => "BPF_PROG_TYPE_SYSCALL",
            Self::BpfProgTypeNetfilter => "BPF_PROG_TYPE_NETFILTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BPF_PROG_TYPE_UNSPEC" => Some(Self::BpfProgTypeUnspec),
            "BPF_PROG_TYPE_SOCKET_FILTER" => Some(Self::BpfProgTypeSocketFilter),
            "BPF_PROG_TYPE_KPROBE" => Some(Self::BpfProgTypeKprobe),
            "BPF_PROG_TYPE_SCHED_CLS" => Some(Self::BpfProgTypeSchedCls),
            "BPF_PROG_TYPE_SCHED_ACT" => Some(Self::BpfProgTypeSchedAct),
            "BPF_PROG_TYPE_TRACEPOINT" => Some(Self::BpfProgTypeTracepoint),
            "BPF_PROG_TYPE_XDP" => Some(Self::BpfProgTypeXdp),
            "BPF_PROG_TYPE_PERF_EVENT" => Some(Self::BpfProgTypePerfEvent),
            "BPF_PROG_TYPE_CGROUP_SKB" => Some(Self::BpfProgTypeCgroupSkb),
            "BPF_PROG_TYPE_CGROUP_SOCK" => Some(Self::BpfProgTypeCgroupSock),
            "BPF_PROG_TYPE_LWT_IN" => Some(Self::BpfProgTypeLwtIn),
            "BPF_PROG_TYPE_LWT_OUT" => Some(Self::BpfProgTypeLwtOut),
            "BPF_PROG_TYPE_LWT_XMIT" => Some(Self::BpfProgTypeLwtXmit),
            "BPF_PROG_TYPE_SOCK_OPS" => Some(Self::BpfProgTypeSockOps),
            "BPF_PROG_TYPE_SK_SKB" => Some(Self::BpfProgTypeSkSkb),
            "BPF_PROG_TYPE_CGROUP_DEVICE" => Some(Self::BpfProgTypeCgroupDevice),
            "BPF_PROG_TYPE_SK_MSG" => Some(Self::BpfProgTypeSkMsg),
            "BPF_PROG_TYPE_RAW_TRACEPOINT" => Some(Self::BpfProgTypeRawTracepoint),
            "BPF_PROG_TYPE_CGROUP_SOCK_ADDR" => Some(Self::BpfProgTypeCgroupSockAddr),
            "BPF_PROG_TYPE_LWT_SEG6LOCAL" => Some(Self::BpfProgTypeLwtSeg6local),
            "BPF_PROG_TYPE_LIRC_MODE2" => Some(Self::BpfProgTypeLircMode2),
            "BPF_PROG_TYPE_SK_REUSEPORT" => Some(Self::BpfProgTypeSkReuseport),
            "BPF_PROG_TYPE_FLOW_DISSECTOR" => Some(Self::BpfProgTypeFlowDissector),
            "BPF_PROG_TYPE_CGROUP_SYSCTL" => Some(Self::BpfProgTypeCgroupSysctl),
            "BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE" => {
                Some(Self::BpfProgTypeRawTracepointWritable)
            }
            "BPF_PROG_TYPE_CGROUP_SOCKOPT" => Some(Self::BpfProgTypeCgroupSockopt),
            "BPF_PROG_TYPE_TRACING" => Some(Self::BpfProgTypeTracing),
            "BPF_PROG_TYPE_STRUCT_OPS" => Some(Self::BpfProgTypeStructOps),
            "BPF_PROG_TYPE_EXT" => Some(Self::BpfProgTypeExt),
            "BPF_PROG_TYPE_LSM" => Some(Self::BpfProgTypeLsm),
            "BPF_PROG_TYPE_SK_LOOKUP" => Some(Self::BpfProgTypeSkLookup),
            "BPF_PROG_TYPE_SYSCALL" => Some(Self::BpfProgTypeSyscall),
            "BPF_PROG_TYPE_NETFILTER" => Some(Self::BpfProgTypeNetfilter),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    /// Identifier of the container image composed of the registry path and the
    /// sha256.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the container image composed of the registry path and the tag.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SecurityContext {
    /// True if this container is priviledged.
    #[prost(bool, tag = "1")]
    pub privileged: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Container {
    /// Identifier of the container.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the container.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Image of the container.
    #[prost(message, optional, tag = "3")]
    pub image: ::core::option::Option<Image>,
    /// Start time of the container.
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Process identifier in the container namespace.
    #[prost(message, optional, tag = "5")]
    pub pid: ::core::option::Option<u32>,
    /// If this is set true, it means that the process might have been originated from
    /// a Kubernetes exec probe. For this field to be true, the following must be true:
    /// 1. The binary field matches the first element of the exec command list for either
    ///     liveness or readiness probe excluding the basename. For example, "/bin/ls"
    ///     and "ls" are considered a match.
    /// 2. The arguments field exactly matches the rest of the exec command list.
    #[prost(bool, tag = "13")]
    pub maybe_exec_probe: bool,
    /// The security context of the container
    #[prost(message, optional, tag = "14")]
    pub security_context: ::core::option::Option<SecurityContext>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pod {
    /// Kubernetes namespace of the Pod.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Name of the Pod.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// UID of the Pod.
    #[prost(string, tag = "3")]
    pub uid: ::prost::alloc::string::String,
    /// Container of the Pod from which the process that triggered the event
    /// originates.
    #[prost(message, optional, tag = "4")]
    pub container: ::core::option::Option<Container>,
    /// Contains all the labels of the pod.
    #[prost(map = "string, string", tag = "5")]
    pub pod_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Kubernetes workload of the Pod.
    #[prost(string, tag = "6")]
    pub workload: ::prost::alloc::string::String,
    /// Kubernetes workload kind (e.g. "Deployment", "DaemonSet") of the Pod.
    #[prost(string, tag = "7")]
    pub workload_kind: ::prost::alloc::string::String,
    /// Contains all the annotations of the pod.
    #[prost(map = "string, string", tag = "8")]
    pub pod_annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Capabilities {
    /// Permitted set indicates what capabilities the process can use. This is a
    /// limiting superset for the effective capabilities that the thread may
    /// assume. It is also a limiting superset for the capabilities that may be
    /// added to the inheritable set by a thread without the CAP_SETPCAP in its
    /// effective set.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "1")]
    pub permitted: ::prost::alloc::vec::Vec<i32>,
    /// Effective set indicates what capabilities are active in a process. This
    /// is the set used by the kernel to perform permission checks for the
    /// thread.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "2")]
    pub effective: ::prost::alloc::vec::Vec<i32>,
    /// Inheritable set indicates which capabilities will be inherited by the
    /// current process when running as a root user.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "3")]
    pub inheritable: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Namespace {
    /// Inode number of the namespace.
    #[prost(uint32, tag = "1")]
    pub inum: u32,
    /// Indicates if namespace belongs to host.
    #[prost(bool, tag = "2")]
    pub is_host: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Namespaces {
    /// Hostname and NIS domain name.
    #[prost(message, optional, tag = "1")]
    pub uts: ::core::option::Option<Namespace>,
    /// System V IPC, POSIX message queues.
    #[prost(message, optional, tag = "2")]
    pub ipc: ::core::option::Option<Namespace>,
    /// Mount points.
    #[prost(message, optional, tag = "3")]
    pub mnt: ::core::option::Option<Namespace>,
    /// Process IDs.
    #[prost(message, optional, tag = "4")]
    pub pid: ::core::option::Option<Namespace>,
    /// Process IDs for children processes.
    #[prost(message, optional, tag = "5")]
    pub pid_for_children: ::core::option::Option<Namespace>,
    /// Network devices, stacks, ports, etc.
    #[prost(message, optional, tag = "6")]
    pub net: ::core::option::Option<Namespace>,
    /// Boot and monotonic clocks.
    #[prost(message, optional, tag = "7")]
    pub time: ::core::option::Option<Namespace>,
    /// Boot and monotonic clocks for children processes.
    #[prost(message, optional, tag = "8")]
    pub time_for_children: ::core::option::Option<Namespace>,
    /// Cgroup root directory.
    #[prost(message, optional, tag = "9")]
    pub cgroup: ::core::option::Option<Namespace>,
    /// User and group IDs.
    #[prost(message, optional, tag = "10")]
    pub user: ::core::option::Option<Namespace>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserNamespace {
    /// Nested level of the user namespace. Init or host user namespace is at level 0.
    #[prost(message, optional, tag = "1")]
    pub level: ::core::option::Option<i32>,
    /// The owner user ID of the namespace
    #[prost(message, optional, tag = "2")]
    pub uid: ::core::option::Option<u32>,
    /// The owner group ID of the namepace.
    #[prost(message, optional, tag = "3")]
    pub gid: ::core::option::Option<u32>,
    /// The user namespace details that include the inode number of the namespace.
    #[prost(message, optional, tag = "4")]
    pub ns: ::core::option::Option<Namespace>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessCredentials {
    /// The real user ID of the process' owner.
    #[prost(message, optional, tag = "1")]
    pub uid: ::core::option::Option<u32>,
    /// The real group ID of the process' owner.
    #[prost(message, optional, tag = "2")]
    pub gid: ::core::option::Option<u32>,
    /// The effective user ID used for permission checks.
    #[prost(message, optional, tag = "3")]
    pub euid: ::core::option::Option<u32>,
    /// The effective group ID used for permission checks.
    #[prost(message, optional, tag = "4")]
    pub egid: ::core::option::Option<u32>,
    /// The saved user ID.
    #[prost(message, optional, tag = "5")]
    pub suid: ::core::option::Option<u32>,
    /// The saved group ID.
    #[prost(message, optional, tag = "6")]
    pub sgid: ::core::option::Option<u32>,
    /// the filesystem user ID used for filesystem access checks. Usually equals the euid.
    #[prost(message, optional, tag = "7")]
    pub fsuid: ::core::option::Option<u32>,
    /// The filesystem group ID used for filesystem access checks. Usually equals the egid.
    #[prost(message, optional, tag = "8")]
    pub fsgid: ::core::option::Option<u32>,
    /// Secure management flags
    #[prost(enumeration = "SecureBitsType", repeated, tag = "9")]
    pub securebits: ::prost::alloc::vec::Vec<i32>,
    /// Set of capabilities that define the permissions the process can execute with.
    #[prost(message, optional, tag = "10")]
    pub caps: ::core::option::Option<Capabilities>,
    /// User namespace where the UIDs, GIDs and capabilities are relative to.
    #[prost(message, optional, tag = "11")]
    pub user_ns: ::core::option::Option<UserNamespace>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InodeProperties {
    /// The inode number
    #[prost(uint64, tag = "1")]
    pub number: u64,
    /// The inode links on the file system. If zero means the file is only in memory
    #[prost(message, optional, tag = "2")]
    pub links: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileProperties {
    /// Inode of the file
    #[prost(message, optional, tag = "1")]
    pub inode: ::core::option::Option<InodeProperties>,
    /// Path of the file
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryProperties {
    /// If set then this is the set user ID used for execution
    #[prost(message, optional, tag = "1")]
    pub setuid: ::core::option::Option<u32>,
    /// If set then this is the set group ID used for execution
    #[prost(message, optional, tag = "2")]
    pub setgid: ::core::option::Option<u32>,
    /// The reasons why this binary execution changed privileges. Usually this happens when the process executes
    /// a binary with the set-user-ID to root or file capability sets.
    /// The final granted privileges can be listed inside the `process_credentials` or capabilities fields part of of the `process` object.
    #[prost(enumeration = "ProcessPrivilegesChanged", repeated, tag = "3")]
    pub privileges_changed: ::prost::alloc::vec::Vec<i32>,
    /// File properties in case the executed binary is:
    /// 1. An anonymous shared memory file <https://man7.org/linux/man-pages/man7/shm_overview.7.html.>
    /// 2. An anonymous file obtained with memfd API <https://man7.org/linux/man-pages/man2/memfd_create.2.html.>
    /// 3. Or it was deleted from the file system.
    #[prost(message, optional, tag = "4")]
    pub file: ::core::option::Option<FileProperties>,
}
/// User records
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserRecord {
    /// The UNIX username for this record. Corresponds to `pw_name` field of [struct passwd](<https://man7.org/linux/man-pages/man3/getpwnam.3.html>)
    /// and the `sp_namp` field of [struct spwd](<https://man7.org/linux/man-pages/man3/getspnam.3.html>).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    /// Exec ID uniquely identifies the process over time across all the nodes in the cluster.
    #[prost(string, tag = "1")]
    pub exec_id: ::prost::alloc::string::String,
    /// Process identifier from host PID namespace.
    #[prost(message, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    /// The effective User identifier used for permission checks. This field maps to the
    /// 'ProcessCredentials.euid' field. Run with the `--enable-process-cred` flag to
    /// enable 'ProcessCredentials' and get all the User and Group identifiers.
    #[prost(message, optional, tag = "3")]
    pub uid: ::core::option::Option<u32>,
    /// Current working directory of the process.
    #[prost(string, tag = "4")]
    pub cwd: ::prost::alloc::string::String,
    /// Absolute path of the executed binary.
    #[prost(string, tag = "5")]
    pub binary: ::prost::alloc::string::String,
    /// Arguments passed to the binary at execution.
    #[prost(string, tag = "6")]
    pub arguments: ::prost::alloc::string::String,
    /// Flags are for debugging purposes only and should not be considered a
    /// reliable source of information. They hold various information about
    /// which syscalls generated events, use of internal Tetragon buffers,
    /// errors and more.
    /// - `execve` This event is generated by an execve syscall for a new
    /// process. See procFs for the other option. A correctly formatted event
    /// should either set execve or procFS (described next).
    /// - `procFS` This event is generated from a proc interface. This happens
    /// at Tetragon init when existing processes are being loaded into Tetragon
    /// event buffer. All events should have either execve or procFS set.
    /// - `truncFilename` Indicates a truncated processes filename because the
    /// buffer size is too small to contain the process filename. Consider
    /// increasing buffer size to avoid this.
    /// - `truncArgs` Indicates truncated the processes arguments because the
    /// buffer size was too small to contain all exec args. Consider increasing
    /// buffer size to avoid this.
    /// - `taskWalk` Primarily useful for debugging. Indicates a walked process
    /// hierarchy to find a parent process in the Tetragon buffer. This may
    /// happen when we did not receive an exec event for the immediate parent of
    /// a process. Typically means we are looking at a fork that in turn did
    /// another fork we don't currently track fork events exactly and instead
    /// push an event with the original parent exec data. This flag can provide
    /// this insight into the event if needed.
    /// - `miss` An error flag indicating we could not find parent info in the
    /// Tetragon event buffer. If this is set it should be reported to Tetragon
    /// developers for debugging. Tetragon will do its best to recover
    /// information about the process from available kernel data structures
    /// instead of using cached info in this case. However, args will not be
    /// available.
    /// - `needsAUID` An internal flag for Tetragon to indicate the audit has
    /// not yet been resolved. The BPF hooks look at this flag to determine if
    /// probing the audit system is necessary.
    /// - `errorFilename` An error flag indicating an error happened while
    /// reading the filename. If this is set it should be reported to Tetragon
    /// developers for debugging.
    /// - `errorArgs` An error flag indicating an error happened while reading
    /// the process args. If this is set it should be reported to Tetragon
    /// developers for debugging
    /// - `needsCWD` An internal flag for Tetragon to indicate the current
    /// working directory has not yet been resolved. The Tetragon hooks look at
    /// this flag to determine if probing the CWD is necessary.
    /// - `noCWDSupport` Indicates that CWD is removed from the event because
    /// the buffer size is too small. Consider increasing buffer size to avoid
    /// this.
    /// - `rootCWD` Indicates that CWD is the root directory. This is necessary
    /// to inform readers the CWD is not in the event buffer and is '/' instead.
    /// - `errorCWD` An error flag indicating an error occurred while reading
    /// the CWD of a process. If this is set it should be reported to Tetragon
    /// developers for debugging.
    /// - `clone` Indicates the process issued a clone before exec*. This is the
    /// general flow to exec* a new process, however its possible to replace the
    /// current process with a new process by doing an exec* without a clone. In
    /// this case the flag will be omitted and the same PID will be used by the
    /// kernel for both the old process and the newly exec'd process.
    /// - `unknown` Indicates the process was not found in the process cache
    /// and contains just pid and start time.
    #[prost(string, tag = "7")]
    pub flags: ::prost::alloc::string::String,
    /// Start time of the execution.
    #[prost(message, optional, tag = "8")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Audit user ID, this ID is assigned to a user upon login and is inherited
    /// by every process even when the user's identity changes. For example, by
    /// switching user accounts with su - john.
    #[prost(message, optional, tag = "9")]
    pub auid: ::core::option::Option<u32>,
    /// Information about the the Kubernetes Pod where the event originated.
    #[prost(message, optional, tag = "10")]
    pub pod: ::core::option::Option<Pod>,
    /// The 15 first digits of the container ID.
    #[prost(string, tag = "11")]
    pub docker: ::prost::alloc::string::String,
    /// Exec ID of the parent process.
    #[prost(string, tag = "12")]
    pub parent_exec_id: ::prost::alloc::string::String,
    /// Reference counter from the Tetragon process cache.
    #[prost(uint32, tag = "13")]
    pub refcnt: u32,
    /// Set of capabilities that define the permissions the process can execute with.
    #[prost(message, optional, tag = "14")]
    pub cap: ::core::option::Option<Capabilities>,
    /// Linux namespaces of the process, disabled by default, can be enabled by
    /// the `--enable-process-ns` flag.
    #[prost(message, optional, tag = "15")]
    pub ns: ::core::option::Option<Namespaces>,
    /// Thread ID, note that for the thread group leader, tid is equal to pid.
    #[prost(message, optional, tag = "16")]
    pub tid: ::core::option::Option<u32>,
    /// Process credentials, disabled by default, can be enabled by the
    /// `--enable-process-cred` flag.
    #[prost(message, optional, tag = "17")]
    pub process_credentials: ::core::option::Option<ProcessCredentials>,
    /// Executed binary properties. This field is only available on ProcessExec events.
    #[prost(message, optional, tag = "18")]
    pub binary_properties: ::core::option::Option<BinaryProperties>,
    /// UserRecord contains user information about the event.
    /// It is only supported when i) Tetragon is running as a systemd service or directly on the host, and
    /// ii) when the flag `--username-metadata` is set to "unix". In this case, the information is retrieved from
    /// the traditional user database `/etc/passwd` and no name services lookups are performed.
    /// The resolution will only be attempted for processes in the host namespace.
    /// Note that this resolution happens in user-space, which means that mapping might have changed
    /// between the in-kernel BPF hook being executed and the username resolution.
    #[prost(message, optional, tag = "19")]
    pub user: ::core::option::Option<UserRecord>,
    /// If set to true, this process is containerized and is a member of the
    /// process tree rooted at pid=1 in its PID namespace. This is useful if,
    /// for example, you wish to discern whether a process was spawned using a
    /// tool like nsenter or kubectl exec.
    #[prost(message, optional, tag = "20")]
    pub in_init_tree: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessExec {
    /// Process that triggered the exec.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "3")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessExit {
    /// Process that triggered the exit.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Signal that the process received when it exited, for example SIGKILL or
    /// SIGTERM (list all signal names with `kill -l`). If there is no signal
    /// handler implemented for a specific process, we report the exit status
    /// code that can be found in the status field.
    #[prost(string, tag = "3")]
    pub signal: ::prost::alloc::string::String,
    /// Status code on process exit. For example, the status code can indicate
    /// if an error was encountered or the program exited successfully.
    #[prost(uint32, tag = "4")]
    pub status: u32,
    /// Date and time of the event.
    #[prost(message, optional, tag = "5")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "6")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeSock {
    #[prost(string, tag = "1")]
    pub family: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub mark: u32,
    #[prost(uint32, tag = "5")]
    pub priority: u32,
    #[prost(string, tag = "6")]
    pub saddr: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub daddr: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub sport: u32,
    #[prost(uint32, tag = "9")]
    pub dport: u32,
    #[prost(uint64, tag = "10")]
    pub cookie: u64,
    #[prost(string, tag = "11")]
    pub state: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeSkb {
    #[prost(uint32, tag = "1")]
    pub hash: u32,
    #[prost(uint32, tag = "2")]
    pub len: u32,
    #[prost(uint32, tag = "3")]
    pub priority: u32,
    #[prost(uint32, tag = "4")]
    pub mark: u32,
    #[prost(string, tag = "5")]
    pub saddr: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub daddr: ::prost::alloc::string::String,
    #[prost(uint32, tag = "7")]
    pub sport: u32,
    #[prost(uint32, tag = "8")]
    pub dport: u32,
    #[prost(uint32, tag = "9")]
    pub proto: u32,
    #[prost(uint32, tag = "10")]
    pub sec_path_len: u32,
    #[prost(uint32, tag = "11")]
    pub sec_path_olen: u32,
    #[prost(string, tag = "12")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub family: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeSockaddr {
    #[prost(string, tag = "1")]
    pub family: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub addr: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub port: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeNetDev {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobePath {
    #[prost(string, tag = "1")]
    pub mount: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub flags: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub permission: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeFile {
    #[prost(string, tag = "1")]
    pub mount: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub flags: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub permission: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeTruncatedBytes {
    #[prost(bytes = "vec", tag = "1")]
    pub bytes_arg: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub orig_size: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeCred {
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "1")]
    pub permitted: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "2")]
    pub effective: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "3")]
    pub inheritable: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeLinuxBinprm {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub flags: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeCapability {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<i32>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KprobeUserNamespace {
    #[prost(message, optional, tag = "1")]
    pub level: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub group: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub ns: ::core::option::Option<Namespace>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeBpfAttr {
    #[prost(string, tag = "1")]
    pub prog_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub insn_cnt: u32,
    #[prost(string, tag = "3")]
    pub prog_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeBpfProg {
    #[prost(string, tag = "1")]
    pub prog_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub insn_cnt: u32,
    #[prost(string, tag = "3")]
    pub prog_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobePerfEvent {
    #[prost(string, tag = "1")]
    pub kprobe_func: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub config: u64,
    #[prost(uint64, tag = "4")]
    pub probe_offset: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeBpfMap {
    #[prost(string, tag = "1")]
    pub map_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub key_size: u32,
    #[prost(uint32, tag = "3")]
    pub value_size: u32,
    #[prost(uint32, tag = "4")]
    pub max_entries: u32,
    #[prost(string, tag = "5")]
    pub map_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyscallId {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub abi: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeArgument {
    #[prost(string, tag = "18")]
    pub label: ::prost::alloc::string::String,
    #[prost(
        oneof = "kprobe_argument::Arg",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31"
    )]
    pub arg: ::core::option::Option<kprobe_argument::Arg>,
}
/// Nested message and enum types in `KprobeArgument`.
pub mod kprobe_argument {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Arg {
        #[prost(string, tag = "1")]
        StringArg(::prost::alloc::string::String),
        #[prost(int32, tag = "2")]
        IntArg(i32),
        #[prost(message, tag = "3")]
        SkbArg(super::KprobeSkb),
        #[prost(uint64, tag = "4")]
        SizeArg(u64),
        #[prost(bytes, tag = "5")]
        BytesArg(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "6")]
        PathArg(super::KprobePath),
        #[prost(message, tag = "7")]
        FileArg(super::KprobeFile),
        #[prost(message, tag = "8")]
        TruncatedBytesArg(super::KprobeTruncatedBytes),
        #[prost(message, tag = "9")]
        SockArg(super::KprobeSock),
        #[prost(message, tag = "10")]
        CredArg(super::KprobeCred),
        #[prost(int64, tag = "11")]
        LongArg(i64),
        #[prost(message, tag = "12")]
        BpfAttrArg(super::KprobeBpfAttr),
        #[prost(message, tag = "13")]
        PerfEventArg(super::KprobePerfEvent),
        #[prost(message, tag = "14")]
        BpfMapArg(super::KprobeBpfMap),
        #[prost(uint32, tag = "15")]
        UintArg(u32),
        #[prost(message, tag = "16")]
        UserNamespaceArg(super::KprobeUserNamespace),
        #[prost(message, tag = "17")]
        CapabilityArg(super::KprobeCapability),
        #[prost(message, tag = "19")]
        ProcessCredentialsArg(super::ProcessCredentials),
        #[prost(message, tag = "20")]
        UserNsArg(super::UserNamespace),
        #[prost(message, tag = "21")]
        ModuleArg(super::KernelModule),
        /// Capabilities in hexadecimal format.
        #[prost(string, tag = "22")]
        KernelCapTArg(::prost::alloc::string::String),
        /// Capabilities inherited by a forked process in hexadecimal format.
        #[prost(string, tag = "23")]
        CapInheritableArg(::prost::alloc::string::String),
        /// Capabilities that are currently permitted in hexadecimal format.
        #[prost(string, tag = "24")]
        CapPermittedArg(::prost::alloc::string::String),
        /// Capabilities that are actually used in hexadecimal format.
        #[prost(string, tag = "25")]
        CapEffectiveArg(::prost::alloc::string::String),
        #[prost(message, tag = "26")]
        LinuxBinprmArg(super::KprobeLinuxBinprm),
        #[prost(message, tag = "27")]
        NetDevArg(super::KprobeNetDev),
        #[prost(enumeration = "super::BpfCmd", tag = "28")]
        BpfCmdArg(i32),
        #[prost(message, tag = "29")]
        SyscallId(super::SyscallId),
        #[prost(message, tag = "30")]
        SockaddrArg(super::KprobeSockaddr),
        #[prost(message, tag = "31")]
        BpfProgArg(super::KprobeBpfProg),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessKprobe {
    /// Process that triggered the kprobe.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Symbol on which the kprobe was attached.
    #[prost(string, tag = "3")]
    pub function_name: ::prost::alloc::string::String,
    /// Arguments definition of the observed kprobe.
    #[prost(message, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Return value definition of the observed kprobe.
    #[prost(message, optional, tag = "5")]
    pub r#return: ::core::option::Option<KprobeArgument>,
    /// Action performed when the kprobe matched.
    #[prost(enumeration = "KprobeAction", tag = "6")]
    pub action: i32,
    /// Kernel stack trace to the call.
    #[prost(message, repeated, tag = "7")]
    pub kernel_stack_trace: ::prost::alloc::vec::Vec<StackTraceEntry>,
    /// Name of the Tracing Policy that created that kprobe.
    #[prost(string, tag = "8")]
    pub policy_name: ::prost::alloc::string::String,
    /// Action performed when the return kprobe executed.
    #[prost(enumeration = "KprobeAction", tag = "9")]
    pub return_action: i32,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "10")]
    pub message: ::prost::alloc::string::String,
    /// Tags of the Tracing Policy to categorize the event.
    #[prost(string, repeated, tag = "11")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// User-mode stack trace to the call.
    #[prost(message, repeated, tag = "12")]
    pub user_stack_trace: ::prost::alloc::vec::Vec<StackTraceEntry>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "13")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
    /// Data definition of the observed kprobe.
    #[prost(message, repeated, tag = "14")]
    pub data: ::prost::alloc::vec::Vec<KprobeArgument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessTracepoint {
    /// Process that triggered the tracepoint.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Subsystem of the tracepoint.
    #[prost(string, tag = "4")]
    pub subsys: ::prost::alloc::string::String,
    /// Event of the subsystem.
    #[prost(string, tag = "5")]
    pub event: ::prost::alloc::string::String,
    /// Arguments definition of the observed tracepoint.
    /// TODO: once we implement all we want, rename KprobeArgument to GenericArgument
    #[prost(message, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Name of the policy that created that tracepoint.
    #[prost(string, tag = "7")]
    pub policy_name: ::prost::alloc::string::String,
    /// Action performed when the tracepoint matched.
    #[prost(enumeration = "KprobeAction", tag = "8")]
    pub action: i32,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
    /// Tags of the Tracing Policy to categorize the event.
    #[prost(string, repeated, tag = "10")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "11")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessUprobe {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub symbol: ::prost::alloc::string::String,
    /// Name of the policy that created that uprobe.
    #[prost(string, tag = "5")]
    pub policy_name: ::prost::alloc::string::String,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    /// Arguments definition of the observed uprobe.
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Tags of the Tracing Policy to categorize the event.
    #[prost(string, repeated, tag = "8")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "9")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
    /// uprobe offset (mutualy exclusive with symbol)
    #[prost(uint64, tag = "10")]
    pub offset: u64,
    /// uprobe ref_ctr_offset
    #[prost(uint64, tag = "11")]
    pub ref_ctr_offset: u64,
    /// Action performed when the uprobe hook matched.
    #[prost(enumeration = "KprobeAction", tag = "12")]
    pub action: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessUsdt {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub provider: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// Name of the policy that created that uprobe.
    #[prost(string, tag = "6")]
    pub policy_name: ::prost::alloc::string::String,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "7")]
    pub message: ::prost::alloc::string::String,
    /// Arguments definition of the observed uprobe.
    #[prost(message, repeated, tag = "8")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Tags of the Tracing Policy to categorize the event.
    #[prost(string, repeated, tag = "9")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "10")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
    /// Action performed when the USDT hook matched.
    #[prost(enumeration = "KprobeAction", tag = "11")]
    pub action: i32,
    /// Flags are for debugging purposes only and should not be considered a
    /// reliable source of information.
    #[prost(string, tag = "12")]
    pub flags: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessLsm {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// LSM hook name.
    #[prost(string, tag = "3")]
    pub function_name: ::prost::alloc::string::String,
    /// Name of the policy that created that LSM hook.
    #[prost(string, tag = "5")]
    pub policy_name: ::prost::alloc::string::String,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    /// Arguments definition of the observed LSM hook.
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Action performed when the LSM hook matched.
    #[prost(enumeration = "KprobeAction", tag = "8")]
    pub action: i32,
    /// Tags of the Tracing Policy to categorize the event.
    #[prost(string, repeated, tag = "9")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "10")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
    /// IMA file hash. Format algorithm:value.
    #[prost(string, tag = "11")]
    pub ima_hash: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelModule {
    /// Kernel module name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If true the module signature was verified successfully. Depends on kernels compiled with
    /// CONFIG_MODULE_SIG option, for details please read: <https://www.kernel.org/doc/Documentation/admin-guide/module-signing.rst>
    #[prost(message, optional, tag = "2")]
    pub signature_ok: ::core::option::Option<bool>,
    /// The module tainted flags that will be applied on the kernel. For further details please read: <https://docs.kernel.org/admin-guide/tainted-kernels.html>
    #[prost(enumeration = "TaintedBitsType", repeated, tag = "3")]
    pub tainted: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Test {
    #[prost(uint64, tag = "1")]
    pub arg0: u64,
    #[prost(uint64, tag = "2")]
    pub arg1: u64,
    #[prost(uint64, tag = "3")]
    pub arg2: u64,
    #[prost(uint64, tag = "4")]
    pub arg3: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthStatusRequest {
    #[prost(enumeration = "HealthStatusType", repeated, tag = "1")]
    pub event_set: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthStatus {
    #[prost(enumeration = "HealthStatusType", tag = "1")]
    pub event: i32,
    #[prost(enumeration = "HealthStatusResult", tag = "2")]
    pub status: i32,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub health_status: ::prost::alloc::vec::Vec<HealthStatus>,
}
/// loader sensor event triggered for loaded binary/library
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessLoader {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub buildid: ::prost::alloc::vec::Vec<u8>,
}
/// RuntimeHookRequest synchronously propagates information to the agent about run-time state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeHookRequest {
    #[prost(oneof = "runtime_hook_request::Event", tags = "1")]
    pub event: ::core::option::Option<runtime_hook_request::Event>,
}
/// Nested message and enum types in `RuntimeHookRequest`.
pub mod runtime_hook_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        CreateContainer(super::CreateContainer),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RuntimeHookResponse {}
/// CreateContainer informs the agent that a container was created
/// This is intented to be used by OCI hooks (but not limited to them) and corresponds to the
/// CreateContainer hook:
/// <https://github.com/opencontainers/runtime-spec/blob/main/config.md#createcontainer-hooks.>
///
/// The containerName, containerID, podName, podUID, and podNamespace fields are retrieved from the
/// annotations as a convenience, and may be left empty if the corresponding annotations are not
/// found.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContainer {
    /// cgroupsPath is the cgroups path for the container. The path is expected to be relative to the
    /// cgroups mountpoint. See: <https://github.com/opencontainers/runtime-spec/blob/58ec43f9fc39e0db229b653ae98295bfde74aeab/specs-go/config.go#L174>
    #[prost(string, tag = "1")]
    pub cgroups_path: ::prost::alloc::string::String,
    /// rootDir is the absolute path of the root directory of the container.
    /// See: <https://github.com/opencontainers/runtime-spec/blob/main/specs-go/config.go#L174>
    #[prost(string, tag = "2")]
    pub root_dir: ::prost::alloc::string::String,
    /// annotations are the run-time annotations for the container
    /// see <https://github.com/opencontainers/runtime-spec/blob/main/config.md#annotations>
    #[prost(map = "string, string", tag = "3")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// containerName is the name of the container
    #[prost(string, tag = "4")]
    pub container_name: ::prost::alloc::string::String,
    /// containerID is the id of the container
    #[prost(string, tag = "5")]
    pub container_id: ::prost::alloc::string::String,
    /// podName is the pod name
    #[prost(string, tag = "6")]
    pub pod_name: ::prost::alloc::string::String,
    /// podUID is the pod uid
    #[prost(string, tag = "7")]
    pub pod_uid: ::prost::alloc::string::String,
    /// podNamespace is the namespace of the pod
    #[prost(string, tag = "8")]
    pub pod_namespace: ::prost::alloc::string::String,
    /// containerImage is the full image location (repo + image)
    #[prost(string, tag = "9")]
    pub container_image: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTraceEntry {
    /// linear address of the function in kernel or user space.
    #[prost(uint64, tag = "1")]
    pub address: u64,
    /// offset is the offset into the native instructions for the function.
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    /// symbol is the symbol name of the function.
    #[prost(string, tag = "3")]
    pub symbol: ::prost::alloc::string::String,
    /// module path for user space addresses.
    #[prost(string, tag = "4")]
    pub module: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KprobeAction {
    /// Unknown action
    Unknown = 0,
    /// Post action creates an event (default action).
    Post = 1,
    /// Post action creates a mapping between file descriptors and file names.
    Followfd = 2,
    /// Sigkill action synchronously terminates the process.
    Sigkill = 3,
    /// Post action removes a mapping between file descriptors and file names.
    Unfollowfd = 4,
    /// Override action modifies the return value of the call.
    Override = 5,
    /// Post action dupplicates a mapping between file descriptors and file
    /// names.
    Copyfd = 6,
    /// GetURL action issue an HTTP Get request against an URL from userspace.
    Geturl = 7,
    /// GetURL action issue a DNS lookup against an URL from userspace.
    Dnslookup = 8,
    /// NoPost action suppresses the transmission of the event to userspace.
    Nopost = 9,
    /// Signal action sends specified signal to the process.
    Signal = 10,
    /// TrackSock action tracks socket.
    Tracksock = 11,
    /// UntrackSock action un-tracks socket.
    Untracksock = 12,
    /// NotifyEnforcer action notifies enforcer sensor.
    Notifyenforcer = 13,
    /// CleanupEnforcerNotification action cleanups any state left by NotifyEnforcer
    Cleanupenforcernotification = 14,
    /// Set action sets first USDT argument
    Set = 15,
}
impl KprobeAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "KPROBE_ACTION_UNKNOWN",
            Self::Post => "KPROBE_ACTION_POST",
            Self::Followfd => "KPROBE_ACTION_FOLLOWFD",
            Self::Sigkill => "KPROBE_ACTION_SIGKILL",
            Self::Unfollowfd => "KPROBE_ACTION_UNFOLLOWFD",
            Self::Override => "KPROBE_ACTION_OVERRIDE",
            Self::Copyfd => "KPROBE_ACTION_COPYFD",
            Self::Geturl => "KPROBE_ACTION_GETURL",
            Self::Dnslookup => "KPROBE_ACTION_DNSLOOKUP",
            Self::Nopost => "KPROBE_ACTION_NOPOST",
            Self::Signal => "KPROBE_ACTION_SIGNAL",
            Self::Tracksock => "KPROBE_ACTION_TRACKSOCK",
            Self::Untracksock => "KPROBE_ACTION_UNTRACKSOCK",
            Self::Notifyenforcer => "KPROBE_ACTION_NOTIFYENFORCER",
            Self::Cleanupenforcernotification => {
                "KPROBE_ACTION_CLEANUPENFORCERNOTIFICATION"
            }
            Self::Set => "KPROBE_ACTION_SET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KPROBE_ACTION_UNKNOWN" => Some(Self::Unknown),
            "KPROBE_ACTION_POST" => Some(Self::Post),
            "KPROBE_ACTION_FOLLOWFD" => Some(Self::Followfd),
            "KPROBE_ACTION_SIGKILL" => Some(Self::Sigkill),
            "KPROBE_ACTION_UNFOLLOWFD" => Some(Self::Unfollowfd),
            "KPROBE_ACTION_OVERRIDE" => Some(Self::Override),
            "KPROBE_ACTION_COPYFD" => Some(Self::Copyfd),
            "KPROBE_ACTION_GETURL" => Some(Self::Geturl),
            "KPROBE_ACTION_DNSLOOKUP" => Some(Self::Dnslookup),
            "KPROBE_ACTION_NOPOST" => Some(Self::Nopost),
            "KPROBE_ACTION_SIGNAL" => Some(Self::Signal),
            "KPROBE_ACTION_TRACKSOCK" => Some(Self::Tracksock),
            "KPROBE_ACTION_UNTRACKSOCK" => Some(Self::Untracksock),
            "KPROBE_ACTION_NOTIFYENFORCER" => Some(Self::Notifyenforcer),
            "KPROBE_ACTION_CLEANUPENFORCERNOTIFICATION" => {
                Some(Self::Cleanupenforcernotification)
            }
            "KPROBE_ACTION_SET" => Some(Self::Set),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatusType {
    Undef = 0,
    Status = 1,
}
impl HealthStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undef => "HEALTH_STATUS_TYPE_UNDEF",
            Self::Status => "HEALTH_STATUS_TYPE_STATUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_TYPE_UNDEF" => Some(Self::Undef),
            "HEALTH_STATUS_TYPE_STATUS" => Some(Self::Status),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatusResult {
    HealthStatusUndef = 0,
    HealthStatusRunning = 1,
    HealthStatusStopped = 2,
    HealthStatusError = 3,
}
impl HealthStatusResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HealthStatusUndef => "HEALTH_STATUS_UNDEF",
            Self::HealthStatusRunning => "HEALTH_STATUS_RUNNING",
            Self::HealthStatusStopped => "HEALTH_STATUS_STOPPED",
            Self::HealthStatusError => "HEALTH_STATUS_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNDEF" => Some(Self::HealthStatusUndef),
            "HEALTH_STATUS_RUNNING" => Some(Self::HealthStatusRunning),
            "HEALTH_STATUS_STOPPED" => Some(Self::HealthStatusStopped),
            "HEALTH_STATUS_ERROR" => Some(Self::HealthStatusError),
            _ => None,
        }
    }
}
/// Tainted bits to indicate if the kernel was tainted. For further details: <https://docs.kernel.org/admin-guide/tainted-kernels.html>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaintedBitsType {
    TaintUnset = 0,
    /// A proprietary module was loaded.
    TaintProprietaryModule = 1,
    /// A module was force loaded.
    TaintForcedModule = 2,
    /// A module was force unloaded.
    TaintForcedUnloadModule = 4,
    /// A staging driver was loaded.
    TaintStagedModule = 1024,
    /// An out of tree module was loaded.
    TaintOutOfTreeModule = 4096,
    /// An unsigned module was loaded. Supported only on kernels built with CONFIG_MODULE_SIG option.
    TaintUnsignedModule = 8192,
    /// The kernel has been live patched.
    TaintKernelLivePatchModule = 32768,
    /// Loading a test module.
    TaintTestModule = 262144,
}
impl TaintedBitsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TaintUnset => "TAINT_UNSET",
            Self::TaintProprietaryModule => "TAINT_PROPRIETARY_MODULE",
            Self::TaintForcedModule => "TAINT_FORCED_MODULE",
            Self::TaintForcedUnloadModule => "TAINT_FORCED_UNLOAD_MODULE",
            Self::TaintStagedModule => "TAINT_STAGED_MODULE",
            Self::TaintOutOfTreeModule => "TAINT_OUT_OF_TREE_MODULE",
            Self::TaintUnsignedModule => "TAINT_UNSIGNED_MODULE",
            Self::TaintKernelLivePatchModule => "TAINT_KERNEL_LIVE_PATCH_MODULE",
            Self::TaintTestModule => "TAINT_TEST_MODULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAINT_UNSET" => Some(Self::TaintUnset),
            "TAINT_PROPRIETARY_MODULE" => Some(Self::TaintProprietaryModule),
            "TAINT_FORCED_MODULE" => Some(Self::TaintForcedModule),
            "TAINT_FORCED_UNLOAD_MODULE" => Some(Self::TaintForcedUnloadModule),
            "TAINT_STAGED_MODULE" => Some(Self::TaintStagedModule),
            "TAINT_OUT_OF_TREE_MODULE" => Some(Self::TaintOutOfTreeModule),
            "TAINT_UNSIGNED_MODULE" => Some(Self::TaintUnsignedModule),
            "TAINT_KERNEL_LIVE_PATCH_MODULE" => Some(Self::TaintKernelLivePatchModule),
            "TAINT_TEST_MODULE" => Some(Self::TaintTestModule),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(string, repeated, tag = "1")]
    pub binary_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub namespace: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub health_check: ::core::option::Option<bool>,
    #[prost(uint32, repeated, tag = "4")]
    pub pid: ::prost::alloc::vec::Vec<u32>,
    /// Filter by the PID of a process and any of its descendants. Note that this filter is
    /// intended for testing and development purposes only and should not be used in
    /// production. In particular, PID cycling in the OS over longer periods of time may
    /// cause unexpected events to pass this filter.
    #[prost(uint32, repeated, tag = "5")]
    pub pid_set: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "EventType", repeated, tag = "6")]
    pub event_set: ::prost::alloc::vec::Vec<i32>,
    /// Filter by process.pod.name field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "7")]
    pub pod_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter by process.arguments field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "8")]
    pub arguments_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter events by pod labels using Kubernetes label selector syntax:
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors>
    /// Note that this filter never matches events without the pod field (i.e.
    /// host process events).
    #[prost(string, repeated, tag = "9")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter events by tracing policy names
    #[prost(string, repeated, tag = "10")]
    pub policy_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter events by Linux process capability
    #[prost(message, optional, tag = "11")]
    pub capabilities: ::core::option::Option<CapFilter>,
    /// Filter parent process' binary using RE2 regular expression syntax.
    #[prost(string, repeated, tag = "12")]
    pub parent_binary_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter using CEL expressions. CEL filters support IP and CIDR notiation extensions from the k8s project.
    /// See <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#IP> and <https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#CIDR> for details.
    #[prost(string, repeated, tag = "13")]
    pub cel_expression: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter by process.parent.arguments field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "14")]
    pub parent_arguments_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter by the container ID in the process.docker field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "15")]
    pub container_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter containerized processes based on whether they are descendants of
    /// the container's init process. This can be used, for example, to watch
    /// for processes injected into a container via docker exec, kubectl exec, or
    /// similar mechanisms.
    #[prost(message, optional, tag = "16")]
    pub in_init_tree: ::core::option::Option<bool>,
    /// Filter ancestor processes' binaries using RE2 regular expression syntax.
    #[prost(string, repeated, tag = "17")]
    pub ancestor_binary_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter by the container name in the process.pod.container field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "18")]
    pub container_name_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Filter over a set of Linux process capabilities. See `message Capabilities`
/// for more info.  WARNING: Multiple sets are ANDed. For example, if the
/// permitted filter matches, but the effective filter does not, the filter will
/// NOT match.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapFilter {
    /// Filter over the set of permitted capabilities.
    #[prost(message, optional, tag = "1")]
    pub permitted: ::core::option::Option<CapFilterSet>,
    /// Filter over the set of effective capabilities.
    #[prost(message, optional, tag = "2")]
    pub effective: ::core::option::Option<CapFilterSet>,
    /// Filter over the set of inheritable capabilities.
    #[prost(message, optional, tag = "3")]
    pub inheritable: ::core::option::Option<CapFilterSet>,
}
/// Capability set to filter over. NOTE: you may specify only ONE set here.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapFilterSet {
    /// Match if the capability set contains any of the capabilities defined in this filter.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "1")]
    pub any: ::prost::alloc::vec::Vec<i32>,
    /// Match if the capability set contains all of the capabilities defined in this filter.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "2")]
    pub all: ::prost::alloc::vec::Vec<i32>,
    /// Match if the capability set exactly matches all of the capabilities defined in this filter.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "3")]
    pub exactly: ::prost::alloc::vec::Vec<i32>,
    /// Match if the capability set contains none of the capabilities defined in this filter.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "4")]
    pub none: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedactionFilter {
    /// Deprecated, do not use.
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub r#match: ::prost::alloc::vec::Vec<Filter>,
    /// RE2 regular expressions to use for redaction. Strings inside capture groups are redacted.
    #[prost(string, repeated, tag = "2")]
    pub redact: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// RE2 regular expression to match binary name. If supplied, redactions will only be applied to matching processes.
    #[prost(string, repeated, tag = "3")]
    pub binary_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldFilter {
    /// Event types to filter or undefined to filter over all event types.
    #[prost(enumeration = "EventType", repeated, tag = "1")]
    pub event_set: ::prost::alloc::vec::Vec<i32>,
    /// Fields to include or exclude.
    #[prost(message, optional, tag = "2")]
    pub fields: ::core::option::Option<::prost_types::FieldMask>,
    /// Whether to include or exclude fields.
    #[prost(enumeration = "FieldFilterAction", tag = "3")]
    pub action: i32,
    /// Whether or not the event set filter should be inverted.
    #[prost(message, optional, tag = "4")]
    pub invert_event_set: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsRequest {
    /// allow_list specifies a list of filters to apply to only return certain
    /// events. If multiple filters are specified, at least one of them has to
    /// match for an event to be included in the results.
    #[prost(message, repeated, tag = "1")]
    pub allow_list: ::prost::alloc::vec::Vec<Filter>,
    /// deny_list specifies a list of filters to apply to exclude certain events
    /// from the results. If multiple filters are specified, at least one of
    /// them has to match for an event to be excluded.
    /// If both allow_list and deny_list are specified, the results contain the
    /// set difference allow_list - deny_list.
    #[prost(message, repeated, tag = "2")]
    pub deny_list: ::prost::alloc::vec::Vec<Filter>,
    /// aggregation_options configures aggregation options for this request.
    /// If this field is not set, responses will not be aggregated.
    /// Note that currently only process_accept and process_connect events are
    /// aggregated. Other events remain unaggregated.
    #[prost(message, optional, tag = "3")]
    pub aggregation_options: ::core::option::Option<AggregationOptions>,
    /// Fields to include or exclude for events in the GetEventsResponse. Omitting this
    /// field implies that all fields will be included. Exclusion always takes precedence
    /// over inclusion in the case of conflicts.
    #[prost(message, repeated, tag = "4")]
    pub field_filters: ::prost::alloc::vec::Vec<FieldFilter>,
}
/// AggregationOptions defines configuration options for aggregating events.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AggregationOptions {
    /// Aggregation window size. Defaults to 15 seconds if this field is not set.
    #[prost(message, optional, tag = "1")]
    pub window_size: ::core::option::Option<::prost_types::Duration>,
    /// Size of the buffer for the aggregator to receive incoming events. If the
    /// buffer becomes full, the aggregator will log a warning and start dropping
    /// incoming events.
    #[prost(uint64, tag = "2")]
    pub channel_buffer_size: u64,
}
/// AggregationInfo contains information about aggregation results.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AggregationInfo {
    /// Total count of events in this aggregation time window.
    #[prost(uint64, tag = "1")]
    pub count: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RateLimitInfo {
    #[prost(uint64, tag = "1")]
    pub number_of_dropped_process_events: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessThrottle {
    /// Throttle type
    #[prost(enumeration = "ThrottleType", tag = "1")]
    pub r#type: i32,
    /// Cgroup name
    #[prost(string, tag = "2")]
    pub cgroup: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsResponse {
    /// Name of the node where this event was observed.
    #[prost(string, tag = "1000")]
    pub node_name: ::prost::alloc::string::String,
    /// Timestamp at which this event was observed.
    /// For an aggregated response, this field to set to the timestamp at which
    /// the event was observed for the first time in a given aggregation time window.
    #[prost(message, optional, tag = "1001")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// aggregation_info contains information about aggregation results. This field
    /// is set only for aggregated responses.
    #[prost(message, optional, tag = "1002")]
    pub aggregation_info: ::core::option::Option<AggregationInfo>,
    /// Name of the cluster where this event was observed.
    #[prost(string, tag = "1003")]
    pub cluster_name: ::prost::alloc::string::String,
    /// Labels associated with the node where this event was observed.
    #[prost(map = "string, string", tag = "1004")]
    pub node_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The type-specific fields of an event.
    ///
    /// NOTE: Numbers must stay in sync with enum EventType.
    #[prost(
        oneof = "get_events_response::Event",
        tags = "1, 5, 9, 10, 11, 12, 27, 28, 29, 40000, 40001"
    )]
    pub event: ::core::option::Option<get_events_response::Event>,
}
/// Nested message and enum types in `GetEventsResponse`.
pub mod get_events_response {
    /// The type-specific fields of an event.
    ///
    /// NOTE: Numbers must stay in sync with enum EventType.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// ProcessExec event includes information about the execution of
        /// binaries and other related process metadata.
        #[prost(message, tag = "1")]
        ProcessExec(super::ProcessExec),
        /// ProcessExit event indicates how and when a process terminates.
        #[prost(message, tag = "5")]
        ProcessExit(super::ProcessExit),
        /// ProcessKprobe event contains information about the pre-defined
        /// functions and the process that invoked them.
        #[prost(message, tag = "9")]
        ProcessKprobe(super::ProcessKprobe),
        /// ProcessTracepoint contains information about the pre-defined
        /// tracepoint and the process that invoked them.
        #[prost(message, tag = "10")]
        ProcessTracepoint(super::ProcessTracepoint),
        #[prost(message, tag = "11")]
        ProcessLoader(super::ProcessLoader),
        #[prost(message, tag = "12")]
        ProcessUprobe(super::ProcessUprobe),
        #[prost(message, tag = "27")]
        ProcessThrottle(super::ProcessThrottle),
        #[prost(message, tag = "28")]
        ProcessLsm(super::ProcessLsm),
        #[prost(message, tag = "29")]
        ProcessUsdt(super::ProcessUsdt),
        #[prost(message, tag = "40000")]
        Test(super::Test),
        #[prost(message, tag = "40001")]
        RateLimitInfo(super::RateLimitInfo),
    }
}
/// Represents the type of a Tetragon event.
///
/// NOTE: EventType constants must be in sync with the numbers used in the
/// GetEventsResponse event oneof.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    Undef = 0,
    ProcessExec = 1,
    ProcessExit = 5,
    ProcessKprobe = 9,
    ProcessTracepoint = 10,
    ProcessLoader = 11,
    ProcessUprobe = 12,
    ProcessThrottle = 27,
    ProcessLsm = 28,
    ProcessUsdt = 29,
    Test = 40000,
    RateLimitInfo = 40001,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undef => "UNDEF",
            Self::ProcessExec => "PROCESS_EXEC",
            Self::ProcessExit => "PROCESS_EXIT",
            Self::ProcessKprobe => "PROCESS_KPROBE",
            Self::ProcessTracepoint => "PROCESS_TRACEPOINT",
            Self::ProcessLoader => "PROCESS_LOADER",
            Self::ProcessUprobe => "PROCESS_UPROBE",
            Self::ProcessThrottle => "PROCESS_THROTTLE",
            Self::ProcessLsm => "PROCESS_LSM",
            Self::ProcessUsdt => "PROCESS_USDT",
            Self::Test => "TEST",
            Self::RateLimitInfo => "RATE_LIMIT_INFO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNDEF" => Some(Self::Undef),
            "PROCESS_EXEC" => Some(Self::ProcessExec),
            "PROCESS_EXIT" => Some(Self::ProcessExit),
            "PROCESS_KPROBE" => Some(Self::ProcessKprobe),
            "PROCESS_TRACEPOINT" => Some(Self::ProcessTracepoint),
            "PROCESS_LOADER" => Some(Self::ProcessLoader),
            "PROCESS_UPROBE" => Some(Self::ProcessUprobe),
            "PROCESS_THROTTLE" => Some(Self::ProcessThrottle),
            "PROCESS_LSM" => Some(Self::ProcessLsm),
            "PROCESS_USDT" => Some(Self::ProcessUsdt),
            "TEST" => Some(Self::Test),
            "RATE_LIMIT_INFO" => Some(Self::RateLimitInfo),
            _ => None,
        }
    }
}
/// Determines the behavior of a field filter
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldFilterAction {
    Include = 0,
    Exclude = 1,
}
impl FieldFilterAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Include => "INCLUDE",
            Self::Exclude => "EXCLUDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INCLUDE" => Some(Self::Include),
            "EXCLUDE" => Some(Self::Exclude),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThrottleType {
    ThrottleUnknown = 0,
    ThrottleStart = 1,
    ThrottleStop = 2,
}
impl ThrottleType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ThrottleUnknown => "THROTTLE_UNKNOWN",
            Self::ThrottleStart => "THROTTLE_START",
            Self::ThrottleStop => "THROTTLE_STOP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THROTTLE_UNKNOWN" => Some(Self::ThrottleUnknown),
            "THROTTLE_START" => Some(Self::ThrottleStart),
            "THROTTLE_STOP" => Some(Self::ThrottleStop),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackAddress {
    #[prost(uint64, tag = "1")]
    pub address: u64,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTrace {
    #[prost(message, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<StackAddress>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTraceLabel {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub count: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTraceNode {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<StackAddress>,
    #[prost(uint64, tag = "2")]
    pub count: u64,
    #[prost(message, repeated, tag = "3")]
    pub labels: ::prost::alloc::vec::Vec<StackTraceLabel>,
    #[prost(message, repeated, tag = "4")]
    pub children: ::prost::alloc::vec::Vec<StackTraceNode>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListSensorsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorStatus {
    /// name is the name of the sensor
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// enabled marks whether the sensor is enabled
    #[prost(bool, tag = "2")]
    pub enabled: bool,
    /// collection is the collection the sensor belongs to (typically a tracing policy)
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSensorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sensors: ::prost::alloc::vec::Vec<SensorStatus>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListTracingPoliciesRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TracingPolicyActionCounters {
    /// number of post events generated from the policy
    #[prost(uint64, tag = "1")]
    pub post: u64,
    /// number of signals sent from the policy
    #[prost(uint64, tag = "2")]
    pub signal: u64,
    /// number of signals that were not sent because the policy was in monitor mode
    #[prost(uint64, tag = "3")]
    pub monitor_signal: u64,
    /// number of return overrides
    #[prost(uint64, tag = "4")]
    pub r#override: u64,
    /// number of return overrides that did not occur because the policy was in monitor mode
    #[prost(uint64, tag = "5")]
    pub monitor_override: u64,
    /// number of enforcer notifications triggered from the policy
    #[prost(uint64, tag = "6")]
    pub notify_enforcer: u64,
    /// number of enforcer notifications that did not occur because the policy was in monitor mode
    #[prost(uint64, tag = "7")]
    pub monitor_notify_enforcer: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TracingPolicyStats {
    #[prost(message, optional, tag = "1")]
    pub action_counters: ::core::option::Option<TracingPolicyActionCounters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracingPolicyStatus {
    /// id is the id of the policy
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// name is the name of the policy
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// namespace is the namespace of the policy (or empty of the policy is global)
    #[prost(string, tag = "3")]
    pub namespace: ::prost::alloc::string::String,
    /// info is additional information about the policy
    #[prost(string, tag = "4")]
    pub info: ::prost::alloc::string::String,
    /// sensors loaded in the scope of this policy
    #[prost(string, repeated, tag = "5")]
    pub sensors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// indicating if the policy is enabled. Deprecated: use 'state' instead.
    #[deprecated]
    #[prost(bool, tag = "6")]
    pub enabled: bool,
    /// filter ID of the policy used for k8s filtering
    #[prost(uint64, tag = "7")]
    pub filter_id: u64,
    /// potential error of the policy
    #[prost(string, tag = "8")]
    pub error: ::prost::alloc::string::String,
    /// current state of the tracing policy
    #[prost(enumeration = "TracingPolicyState", tag = "9")]
    pub state: i32,
    /// the amount of kernel memory in bytes used by policy's sensors non-shared BPF maps (memlock)
    #[prost(uint64, tag = "10")]
    pub kernel_memory_bytes: u64,
    /// current mode of the tracing policy
    #[prost(enumeration = "TracingPolicyMode", tag = "11")]
    pub mode: i32,
    /// stats of the tracing policy
    #[prost(message, optional, tag = "12")]
    pub stats: ::core::option::Option<TracingPolicyStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTracingPoliciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub policies: ::prost::alloc::vec::Vec<TracingPolicyStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub yaml: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigureTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "3")]
    pub enable: ::core::option::Option<bool>,
    #[prost(enumeration = "TracingPolicyMode", optional, tag = "4")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfigureTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveSensorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveSensorResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableSensorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableSensorResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableSensorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableSensorResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStackTraceTreeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStackTraceTreeResponse {
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<StackTraceNode>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DumpProcessCacheReqArgs {
    #[prost(bool, tag = "1")]
    pub skip_zero_refcnt: bool,
    #[prost(bool, tag = "2")]
    pub exclude_execve_map_processes: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessInternal {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(string, tag = "2")]
    pub color: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub refcnt: ::core::option::Option<u32>,
    /// refcnt_ops is a map of operations to refcnt change
    /// keys can be:
    /// - "process++": process increased refcnt (i.e. this process starts)
    /// - "process--": process decreased refcnt (i.e. this process exits)
    /// - "parent++": parent increased refcnt (i.e. a process starts that has this process as a parent)
    /// - "parent--": parent decreased refcnt (i.e. a process exits that has this process as a parent)
    /// - "ancestor++": ancestor increased refcnt (i.e. a process starts that has this process as an ancestor)
    /// - "ancestor--": ancestor decreased refcnt (i.e. a process exits that has this process as an ancestor)
    #[prost(map = "string, int32", tag = "4")]
    pub refcnt_ops: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DumpProcessCacheResArgs {
    #[prost(message, repeated, tag = "1")]
    pub processes: ::prost::alloc::vec::Vec<ProcessInternal>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetDebugRequest {
    #[prost(enumeration = "ConfigFlag", tag = "1")]
    pub flag: i32,
    #[prost(oneof = "get_debug_request::Arg", tags = "2")]
    pub arg: ::core::option::Option<get_debug_request::Arg>,
}
/// Nested message and enum types in `GetDebugRequest`.
pub mod get_debug_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Arg {
        #[prost(message, tag = "2")]
        Dump(super::DumpProcessCacheReqArgs),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDebugResponse {
    #[prost(enumeration = "ConfigFlag", tag = "1")]
    pub flag: i32,
    #[prost(oneof = "get_debug_response::Arg", tags = "2, 3")]
    pub arg: ::core::option::Option<get_debug_response::Arg>,
}
/// Nested message and enum types in `GetDebugResponse`.
pub mod get_debug_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Arg {
        #[prost(enumeration = "super::LogLevel", tag = "2")]
        Level(i32),
        #[prost(message, tag = "3")]
        Processes(super::DumpProcessCacheResArgs),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetDebugRequest {
    #[prost(enumeration = "ConfigFlag", tag = "1")]
    pub flag: i32,
    #[prost(oneof = "set_debug_request::Arg", tags = "2")]
    pub arg: ::core::option::Option<set_debug_request::Arg>,
}
/// Nested message and enum types in `SetDebugRequest`.
pub mod set_debug_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Arg {
        #[prost(enumeration = "super::LogLevel", tag = "2")]
        Level(i32),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetDebugResponse {
    #[prost(enumeration = "ConfigFlag", tag = "1")]
    pub flag: i32,
    #[prost(oneof = "set_debug_response::Arg", tags = "2")]
    pub arg: ::core::option::Option<set_debug_response::Arg>,
}
/// Nested message and enum types in `SetDebugResponse`.
pub mod set_debug_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Arg {
        #[prost(enumeration = "super::LogLevel", tag = "2")]
        Level(i32),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TracingPolicyState {
    /// unknown state
    TpStateUnknown = 0,
    /// loaded and enabled
    TpStateEnabled = 1,
    /// loaded but disabled
    TpStateDisabled = 2,
    /// failed to load
    TpStateLoadError = 3,
    /// failed during lifetime
    TpStateError = 4,
    /// in the process of loading
    TpStateLoading = 5,
    /// in the process of unloading
    TpStateUnloading = 6,
}
impl TracingPolicyState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TpStateUnknown => "TP_STATE_UNKNOWN",
            Self::TpStateEnabled => "TP_STATE_ENABLED",
            Self::TpStateDisabled => "TP_STATE_DISABLED",
            Self::TpStateLoadError => "TP_STATE_LOAD_ERROR",
            Self::TpStateError => "TP_STATE_ERROR",
            Self::TpStateLoading => "TP_STATE_LOADING",
            Self::TpStateUnloading => "TP_STATE_UNLOADING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TP_STATE_UNKNOWN" => Some(Self::TpStateUnknown),
            "TP_STATE_ENABLED" => Some(Self::TpStateEnabled),
            "TP_STATE_DISABLED" => Some(Self::TpStateDisabled),
            "TP_STATE_LOAD_ERROR" => Some(Self::TpStateLoadError),
            "TP_STATE_ERROR" => Some(Self::TpStateError),
            "TP_STATE_LOADING" => Some(Self::TpStateLoading),
            "TP_STATE_UNLOADING" => Some(Self::TpStateUnloading),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TracingPolicyMode {
    TpModeUnknown = 0,
    TpModeEnforce = 1,
    TpModeMonitor = 2,
}
impl TracingPolicyMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TpModeUnknown => "TP_MODE_UNKNOWN",
            Self::TpModeEnforce => "TP_MODE_ENFORCE",
            Self::TpModeMonitor => "TP_MODE_MONITOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TP_MODE_UNKNOWN" => Some(Self::TpModeUnknown),
            "TP_MODE_ENFORCE" => Some(Self::TpModeEnforce),
            "TP_MODE_MONITOR" => Some(Self::TpModeMonitor),
            _ => None,
        }
    }
}
/// For now, we only want to support debug-related config flags to be configurable.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigFlag {
    LogLevel = 0,
    DumpProcessCache = 1,
}
impl ConfigFlag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LogLevel => "CONFIG_FLAG_LOG_LEVEL",
            Self::DumpProcessCache => "CONFIG_FLAG_DUMP_PROCESS_CACHE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONFIG_FLAG_LOG_LEVEL" => Some(Self::LogLevel),
            "CONFIG_FLAG_DUMP_PROCESS_CACHE" => Some(Self::DumpProcessCache),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogLevel {
    Panic = 0,
    Fatal = 1,
    Error = 2,
    Warn = 3,
    Info = 4,
    Debug = 5,
    Trace = 6,
}
impl LogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Panic => "LOG_LEVEL_PANIC",
            Self::Fatal => "LOG_LEVEL_FATAL",
            Self::Error => "LOG_LEVEL_ERROR",
            Self::Warn => "LOG_LEVEL_WARN",
            Self::Info => "LOG_LEVEL_INFO",
            Self::Debug => "LOG_LEVEL_DEBUG",
            Self::Trace => "LOG_LEVEL_TRACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOG_LEVEL_PANIC" => Some(Self::Panic),
            "LOG_LEVEL_FATAL" => Some(Self::Fatal),
            "LOG_LEVEL_ERROR" => Some(Self::Error),
            "LOG_LEVEL_WARN" => Some(Self::Warn),
            "LOG_LEVEL_INFO" => Some(Self::Info),
            "LOG_LEVEL_DEBUG" => Some(Self::Debug),
            "LOG_LEVEL_TRACE" => Some(Self::Trace),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod fine_guidance_sensors_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FineGuidanceSensorsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FineGuidanceSensorsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FineGuidanceSensorsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FineGuidanceSensorsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FineGuidanceSensorsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_events(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetEventsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetEvents"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHealthStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetHealthStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetHealth"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn add_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::AddTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/AddTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tetragon.FineGuidanceSensors", "AddTracingPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/DeleteTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "DeleteTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_tracing_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTracingPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTracingPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/ListTracingPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "ListTracingPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ConfigureTracingPolicy can be used to configure a loaded tracing policy.
        /// It can be used to:
        ///   - enable/disable it
        ///   - change its mode (enforcement vs monitoring)
        /// If multiple changes are requested and an error is encountered, the resulting state might have
        /// partial updates applied. In other words, the configuring a tracing policy is not atomic.
        pub async fn configure_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfigureTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConfigureTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/ConfigureTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "ConfigureTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn enable_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnableTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/EnableTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "EnableTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn disable_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisableTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/DisableTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "DisableTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn list_sensors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSensorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSensorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/ListSensors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "ListSensors"));
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn enable_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnableSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/EnableSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "EnableSensor"));
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn disable_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisableSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/DisableSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tetragon.FineGuidanceSensors", "DisableSensor"),
                );
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn remove_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/RemoveSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "RemoveSensor"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_stack_trace_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStackTraceTreeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStackTraceTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetStackTraceTree",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tetragon.FineGuidanceSensors", "GetStackTraceTree"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn runtime_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::RuntimeHookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeHookResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/RuntimeHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "RuntimeHook"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_debug(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDebugRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetDebugResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetDebug",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetDebug"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_debug(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDebugRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetDebugResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/SetDebug",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "SetDebug"));
            self.inner.unary(req, path, codec).await
        }
    }
}
