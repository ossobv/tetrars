// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CapabilitiesType {
    /// In a system with the \[_POSIX_CHOWN_RESTRICTED\] option defined, this
    /// overrides the restriction of changing file ownership and group
    /// ownership.
    CapChown = 0,
    /// Override all DAC access, including ACL execute access if
    /// \[_POSIX_ACL\] is defined. Excluding DAC access covered by
    /// CAP_LINUX_IMMUTABLE.
    DacOverride = 1,
    /// Overrides all DAC restrictions regarding read and search on files
    /// and directories, including ACL restrictions if \[_POSIX_ACL\] is
    /// defined. Excluding DAC access covered by "$1"_LINUX_IMMUTABLE.
    CapDacReadSearch = 2,
    /// Overrides all restrictions about allowed operations on files, where
    /// file owner ID must be equal to the user ID, except where CAP_FSETID
    /// is applicable. It doesn't override MAC and DAC restrictions.
    CapFowner = 3,
    /// Overrides the following restrictions that the effective user ID
    /// shall match the file owner ID when setting the S_ISUID and S_ISGID
    /// bits on that file; that the effective group ID (or one of the
    /// supplementary group IDs) shall match the file owner ID when setting
    /// the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
    /// cleared on successful return from chown(2) (not implemented).
    CapFsetid = 4,
    /// Overrides the restriction that the real or effective user ID of a
    /// process sending a signal must match the real or effective user ID
    /// of the process receiving the signal.
    CapKill = 5,
    /// Allows forged gids on socket credentials passing.
    CapSetgid = 6,
    /// Allows forged pids on socket credentials passing.
    CapSetuid = 7,
    /// Without VFS support for capabilities:
    ///    Transfer any capability in your permitted set to any pid,
    ///    remove any capability in your permitted set from any pid
    /// With VFS support for capabilities (neither of above, but)
    ///    Add any capability from current's capability bounding set
    ///        to the current process' inheritable set
    ///    Allow taking bits out of capability bounding set
    ///    Allow modification of the securebits for a process
    CapSetpcap = 8,
    /// Allow modification of S_IMMUTABLE and S_APPEND file attributes
    CapLinuxImmutable = 9,
    /// Allows binding to ATM VCIs below 32
    CapNetBindService = 10,
    /// Allow broadcasting, listen to multicast
    CapNetBroadcast = 11,
    /// Allow activation of ATM control sockets
    CapNetAdmin = 12,
    /// Allow binding to any address for transparent proxying (also via NET_ADMIN)
    CapNetRaw = 13,
    /// Allow mlock and mlockall (which doesn't really have anything to do
    /// with IPC)
    CapIpcLock = 14,
    /// Override IPC ownership checks
    CapIpcOwner = 15,
    /// Insert and remove kernel modules - modify kernel without limit
    CapSysModule = 16,
    /// Allow sending USB messages to any device via /dev/bus/usb
    CapSysRawio = 17,
    /// Allow use of chroot()
    CapSysChroot = 18,
    /// Allow ptrace() of any process
    CapSysPtrace = 19,
    /// Allow configuration of process accounting
    CapSysPacct = 20,
    /// Allow everything under CAP_BPF and CAP_PERFMON for backward compatibility
    CapSysAdmin = 21,
    /// Allow use of reboot()
    CapSysBoot = 22,
    /// Allow setting cpu affinity on other processes
    CapSysNice = 23,
    /// Control memory reclaim behavior
    CapSysResource = 24,
    /// Allow setting the real-time clock
    CapSysTime = 25,
    /// Allow vhangup() of tty
    CapSysTtyConfig = 26,
    /// Allow the privileged aspects of mknod()
    CapMknod = 27,
    /// Allow taking of leases on files
    CapLease = 28,
    /// Allow writing the audit log via unicast netlink socket
    CapAuditWrite = 29,
    /// Allow configuration of audit via unicast netlink socket
    CapAuditControl = 30,
    /// Set or remove capabilities on files
    CapSetfcap = 31,
    /// Override MAC access.
    /// The base kernel enforces no MAC policy.
    /// An LSM may enforce a MAC policy, and if it does and it chooses
    /// to implement capability based overrides of that policy, this is
    /// the capability it should use to do so.
    CapMacOverride = 32,
    /// Allow MAC configuration or state changes.
    /// The base kernel requires no MAC configuration.
    /// An LSM may enforce a MAC policy, and if it does and it chooses
    /// to implement capability based checks on modifications to that
    /// policy or the data required to maintain it, this is the
    /// capability it should use to do so.
    CapMacAdmin = 33,
    /// Allow configuring the kernel's syslog (printk behaviour)
    CapSyslog = 34,
    /// Allow triggering something that will wake the system
    CapWakeAlarm = 35,
    /// Allow preventing system suspends
    CapBlockSuspend = 36,
    /// Allow reading the audit log via multicast netlink socket
    CapAuditRead = 37,
    ///
    /// Allow system performance and observability privileged operations
    /// using perf_events, i915_perf and other kernel subsystems
    CapPerfmon = 38,
    ///
    /// CAP_BPF allows the following BPF operations:
    /// - Creating all types of BPF maps
    /// - Advanced verifier features
    ///    - Indirect variable access
    ///    - Bounded loops
    ///    - BPF to BPF function calls
    ///    - Scalar precision tracking
    ///    - Larger complexity limits
    ///    - Dead code elimination
    ///    - And potentially other features
    /// - Loading BPF Type Format (BTF) data
    /// - Retrieve xlated and JITed code of BPF programs
    /// - Use bpf_spin_lock() helper
    /// CAP_PERFMON relaxes the verifier checks further:
    /// - BPF progs can use of pointer-to-integer conversions
    /// - speculation attack hardening measures are bypassed
    /// - bpf_probe_read to read arbitrary kernel memory is allowed
    /// - bpf_trace_printk to print kernel memory is allowed
    /// CAP_SYS_ADMIN is required to use bpf_probe_write_user.
    /// CAP_SYS_ADMIN is required to iterate system wide loaded
    /// programs, maps, links, BTFs and convert their IDs to file descriptors.
    /// CAP_PERFMON and CAP_BPF are required to load tracing programs.
    /// CAP_NET_ADMIN and CAP_BPF are required to load networking programs.
    CapBpf = 39,
    /// Allow writing to ns_last_pid
    CapCheckpointRestore = 40,
}
impl CapabilitiesType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CapChown => "CAP_CHOWN",
            Self::DacOverride => "DAC_OVERRIDE",
            Self::CapDacReadSearch => "CAP_DAC_READ_SEARCH",
            Self::CapFowner => "CAP_FOWNER",
            Self::CapFsetid => "CAP_FSETID",
            Self::CapKill => "CAP_KILL",
            Self::CapSetgid => "CAP_SETGID",
            Self::CapSetuid => "CAP_SETUID",
            Self::CapSetpcap => "CAP_SETPCAP",
            Self::CapLinuxImmutable => "CAP_LINUX_IMMUTABLE",
            Self::CapNetBindService => "CAP_NET_BIND_SERVICE",
            Self::CapNetBroadcast => "CAP_NET_BROADCAST",
            Self::CapNetAdmin => "CAP_NET_ADMIN",
            Self::CapNetRaw => "CAP_NET_RAW",
            Self::CapIpcLock => "CAP_IPC_LOCK",
            Self::CapIpcOwner => "CAP_IPC_OWNER",
            Self::CapSysModule => "CAP_SYS_MODULE",
            Self::CapSysRawio => "CAP_SYS_RAWIO",
            Self::CapSysChroot => "CAP_SYS_CHROOT",
            Self::CapSysPtrace => "CAP_SYS_PTRACE",
            Self::CapSysPacct => "CAP_SYS_PACCT",
            Self::CapSysAdmin => "CAP_SYS_ADMIN",
            Self::CapSysBoot => "CAP_SYS_BOOT",
            Self::CapSysNice => "CAP_SYS_NICE",
            Self::CapSysResource => "CAP_SYS_RESOURCE",
            Self::CapSysTime => "CAP_SYS_TIME",
            Self::CapSysTtyConfig => "CAP_SYS_TTY_CONFIG",
            Self::CapMknod => "CAP_MKNOD",
            Self::CapLease => "CAP_LEASE",
            Self::CapAuditWrite => "CAP_AUDIT_WRITE",
            Self::CapAuditControl => "CAP_AUDIT_CONTROL",
            Self::CapSetfcap => "CAP_SETFCAP",
            Self::CapMacOverride => "CAP_MAC_OVERRIDE",
            Self::CapMacAdmin => "CAP_MAC_ADMIN",
            Self::CapSyslog => "CAP_SYSLOG",
            Self::CapWakeAlarm => "CAP_WAKE_ALARM",
            Self::CapBlockSuspend => "CAP_BLOCK_SUSPEND",
            Self::CapAuditRead => "CAP_AUDIT_READ",
            Self::CapPerfmon => "CAP_PERFMON",
            Self::CapBpf => "CAP_BPF",
            Self::CapCheckpointRestore => "CAP_CHECKPOINT_RESTORE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAP_CHOWN" => Some(Self::CapChown),
            "DAC_OVERRIDE" => Some(Self::DacOverride),
            "CAP_DAC_READ_SEARCH" => Some(Self::CapDacReadSearch),
            "CAP_FOWNER" => Some(Self::CapFowner),
            "CAP_FSETID" => Some(Self::CapFsetid),
            "CAP_KILL" => Some(Self::CapKill),
            "CAP_SETGID" => Some(Self::CapSetgid),
            "CAP_SETUID" => Some(Self::CapSetuid),
            "CAP_SETPCAP" => Some(Self::CapSetpcap),
            "CAP_LINUX_IMMUTABLE" => Some(Self::CapLinuxImmutable),
            "CAP_NET_BIND_SERVICE" => Some(Self::CapNetBindService),
            "CAP_NET_BROADCAST" => Some(Self::CapNetBroadcast),
            "CAP_NET_ADMIN" => Some(Self::CapNetAdmin),
            "CAP_NET_RAW" => Some(Self::CapNetRaw),
            "CAP_IPC_LOCK" => Some(Self::CapIpcLock),
            "CAP_IPC_OWNER" => Some(Self::CapIpcOwner),
            "CAP_SYS_MODULE" => Some(Self::CapSysModule),
            "CAP_SYS_RAWIO" => Some(Self::CapSysRawio),
            "CAP_SYS_CHROOT" => Some(Self::CapSysChroot),
            "CAP_SYS_PTRACE" => Some(Self::CapSysPtrace),
            "CAP_SYS_PACCT" => Some(Self::CapSysPacct),
            "CAP_SYS_ADMIN" => Some(Self::CapSysAdmin),
            "CAP_SYS_BOOT" => Some(Self::CapSysBoot),
            "CAP_SYS_NICE" => Some(Self::CapSysNice),
            "CAP_SYS_RESOURCE" => Some(Self::CapSysResource),
            "CAP_SYS_TIME" => Some(Self::CapSysTime),
            "CAP_SYS_TTY_CONFIG" => Some(Self::CapSysTtyConfig),
            "CAP_MKNOD" => Some(Self::CapMknod),
            "CAP_LEASE" => Some(Self::CapLease),
            "CAP_AUDIT_WRITE" => Some(Self::CapAuditWrite),
            "CAP_AUDIT_CONTROL" => Some(Self::CapAuditControl),
            "CAP_SETFCAP" => Some(Self::CapSetfcap),
            "CAP_MAC_OVERRIDE" => Some(Self::CapMacOverride),
            "CAP_MAC_ADMIN" => Some(Self::CapMacAdmin),
            "CAP_SYSLOG" => Some(Self::CapSyslog),
            "CAP_WAKE_ALARM" => Some(Self::CapWakeAlarm),
            "CAP_BLOCK_SUSPEND" => Some(Self::CapBlockSuspend),
            "CAP_AUDIT_READ" => Some(Self::CapAuditRead),
            "CAP_PERFMON" => Some(Self::CapPerfmon),
            "CAP_BPF" => Some(Self::CapBpf),
            "CAP_CHECKPOINT_RESTORE" => Some(Self::CapCheckpointRestore),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SecureBitsType {
    SecBitNotSet = 0,
    /// When set UID 0 has no special privileges. When unset, inheritance
    /// of root-permissions and suid-root executable under compatibility mode
    /// is supported. If the effective uid of the new process is 0 then
    /// the effective and inheritable bitmasks of the executable file is raised.
    /// If the real uid is 0, the effective (legacy) bit of the executable file
    /// is raised.
    SecBitNoRoot = 1,
    /// Make bit-0 SecBitNoRoot immutable
    SecBitNoRootLocked = 2,
    /// When set, setuid to/from uid 0 does not trigger capability-"fixup".
    /// When unset, to provide compatiblility with old programs relying on
    /// set*uid to gain/lose privilege, transitions to/from uid 0 cause
    /// capabilities to be gained/lost.
    SecBitNoSetUidFixup = 4,
    /// Make bit-2 SecBitNoSetUidFixup immutable
    SecBitNoSetUidFixupLocked = 8,
    /// When set, a process can retain its capabilities even after
    /// transitioning to a non-root user (the set-uid fixup suppressed by
    /// bit 2). Bit-4 is cleared when a process calls exec(); setting both
    /// bit 4 and 5 will create a barrier through exec that no exec()'d
    /// child can use this feature again.
    SecBitKeepCaps = 16,
    /// Make bit-4 SecBitKeepCaps immutable
    SecBitKeepCapsLocked = 32,
    /// When set, a process cannot add new capabilities to its ambient set.
    SecBitNoCapAmbientRaise = 64,
    /// Make bit-6 SecBitNoCapAmbientRaise immutable
    SecBitNoCapAmbientRaiseLocked = 128,
}
impl SecureBitsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SecBitNotSet => "SecBitNotSet",
            Self::SecBitNoRoot => "SecBitNoRoot",
            Self::SecBitNoRootLocked => "SecBitNoRootLocked",
            Self::SecBitNoSetUidFixup => "SecBitNoSetUidFixup",
            Self::SecBitNoSetUidFixupLocked => "SecBitNoSetUidFixupLocked",
            Self::SecBitKeepCaps => "SecBitKeepCaps",
            Self::SecBitKeepCapsLocked => "SecBitKeepCapsLocked",
            Self::SecBitNoCapAmbientRaise => "SecBitNoCapAmbientRaise",
            Self::SecBitNoCapAmbientRaiseLocked => "SecBitNoCapAmbientRaiseLocked",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SecBitNotSet" => Some(Self::SecBitNotSet),
            "SecBitNoRoot" => Some(Self::SecBitNoRoot),
            "SecBitNoRootLocked" => Some(Self::SecBitNoRootLocked),
            "SecBitNoSetUidFixup" => Some(Self::SecBitNoSetUidFixup),
            "SecBitNoSetUidFixupLocked" => Some(Self::SecBitNoSetUidFixupLocked),
            "SecBitKeepCaps" => Some(Self::SecBitKeepCaps),
            "SecBitKeepCapsLocked" => Some(Self::SecBitKeepCapsLocked),
            "SecBitNoCapAmbientRaise" => Some(Self::SecBitNoCapAmbientRaise),
            "SecBitNoCapAmbientRaiseLocked" => Some(Self::SecBitNoCapAmbientRaiseLocked),
            _ => None,
        }
    }
}
/// Reasons of why the process privileges changed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessPrivilegesChanged {
    PrivilegesChangedUnset = 0,
    /// A privilege elevation happened due to the execution of a binary with file capability sets.
    /// The kernel supports associating capability sets with an executable file using `setcap` command.
    /// The file capability sets are stored in an extended attribute (see <https://man7.org/linux/man-pages/man7/xattr.7.html>)
    /// named `security.capability`. The file capability sets, in conjunction with the capability sets
    /// of the process, determine the process capabilities and privileges after the `execve` system call.
    /// For further reference, please check sections `File capability extended attribute versioning` and
    /// `Namespaced file capabilities` of the capabilities man pages: <https://man7.org/linux/man-pages/man7/capabilities.7.html.>
    /// The new granted capabilities can be listed inside the `process` object.
    PrivilegesRaisedExecFileCap = 1,
    /// A privilege elevation happened due to the execution of a binary with set-user-ID to root.
    /// When a process with nonzero UIDs executes a binary with a set-user-ID to root also
    /// known as suid-root executable, then the kernel switches the effective user ID to 0 (root) which
    /// is a privilege elevation operation since it grants access to resources owned by the root user.
    /// The effective user ID is listed inside the `process_credentials` part of the `process` object.
    /// For further reading, section `Capabilities and execution of programs by root` of <https://man7.org/linux/man-pages/man7/capabilities.7.html.>
    /// Afterward the kernel recalculates the capability sets of the process and grants all capabilities
    /// in the permitted and effective capability sets, except those masked out by the capability bounding set.
    /// If the binary also have file capability sets then these bits are honored and the process gains just
    /// the capabilities granted by the file capability sets (i.e., not all capabilities, as it would occur
    /// when executing a set-user-ID to root binary that does not have any associated file capabilities). This
    /// is described in section `Set-user-ID-root programs that have file capabilities` of <https://man7.org/linux/man-pages/man7/capabilities.7.html.>
    /// The new granted capabilities can be listed inside the `process` object.
    /// There is one exception for the special treatments of set-user-ID to root execution receiving all
    /// capabilities, if the `SecBitNoRoot` bit of the Secure bits is set, then the kernel does not grant
    /// any capability. Please check section: `The securebits flags: establishing a capabilities-only environment`
    /// of the capabilities man pages: <https://man7.org/linux/man-pages/man7/capabilities.7.html>
    PrivilegesRaisedExecFileSetuid = 2,
    /// A privilege elevation happened due to the execution of a binary with set-group-ID to root.
    /// When a process with nonzero GIDs executes a binary with a set-group-ID to root, the kernel switches
    /// the effective group ID to 0 (root) which is a privilege elevation operation since it grants access to
    /// resources owned by the root group.
    /// The effective group ID is listed inside the `process_credentials` part of the `process` object.
    PrivilegesRaisedExecFileSetgid = 3,
}
impl ProcessPrivilegesChanged {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PrivilegesChangedUnset => "PRIVILEGES_CHANGED_UNSET",
            Self::PrivilegesRaisedExecFileCap => "PRIVILEGES_RAISED_EXEC_FILE_CAP",
            Self::PrivilegesRaisedExecFileSetuid => "PRIVILEGES_RAISED_EXEC_FILE_SETUID",
            Self::PrivilegesRaisedExecFileSetgid => "PRIVILEGES_RAISED_EXEC_FILE_SETGID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRIVILEGES_CHANGED_UNSET" => Some(Self::PrivilegesChangedUnset),
            "PRIVILEGES_RAISED_EXEC_FILE_CAP" => Some(Self::PrivilegesRaisedExecFileCap),
            "PRIVILEGES_RAISED_EXEC_FILE_SETUID" => {
                Some(Self::PrivilegesRaisedExecFileSetuid)
            }
            "PRIVILEGES_RAISED_EXEC_FILE_SETGID" => {
                Some(Self::PrivilegesRaisedExecFileSetgid)
            }
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    /// Identifier of the container image composed of the registry path and the
    /// sha256.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the container image composed of the registry path and the tag.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Container {
    /// Identifier of the container.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Name of the container.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Image of the container.
    #[prost(message, optional, tag = "3")]
    pub image: ::core::option::Option<Image>,
    /// Start time of the container.
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Process identifier in the container namespace.
    #[prost(message, optional, tag = "5")]
    pub pid: ::core::option::Option<u32>,
    /// If this is set true, it means that the process might have been originated from
    /// a Kubernetes exec probe. For this field to be true, the following must be true:
    /// 1. The binary field matches the first element of the exec command list for either
    ///     liveness or readiness probe excluding the basename. For example, "/bin/ls"
    ///     and "ls" are considered a match.
    /// 2. The arguments field exactly matches the rest of the exec command list.
    #[prost(bool, tag = "13")]
    pub maybe_exec_probe: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pod {
    /// Kubernetes namespace of the Pod.
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// Name of the Pod.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Container of the Pod from which the process that triggered the event
    /// originates.
    #[prost(message, optional, tag = "4")]
    pub container: ::core::option::Option<Container>,
    /// Contains all the labels of the pod.
    #[prost(map = "string, string", tag = "5")]
    pub pod_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Kubernetes workload of the Pod.
    #[prost(string, tag = "6")]
    pub workload: ::prost::alloc::string::String,
    /// Kubernetes workload kind (e.g. "Deployment", "DaemonSet") of the Pod.
    #[prost(string, tag = "7")]
    pub workload_kind: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Capabilities {
    /// Permitted set indicates what capabilities the process can use. This is a
    /// limiting superset for the effective capabilities that the thread may
    /// assume. It is also a limiting superset for the capabilities that may be
    /// added to the inheritable set by a thread without the CAP_SETPCAP in its
    /// effective set.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "1")]
    pub permitted: ::prost::alloc::vec::Vec<i32>,
    /// Effective set indicates what capabilities are active in a process. This
    /// is the set used by the kernel to perform permission checks for the
    /// thread.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "2")]
    pub effective: ::prost::alloc::vec::Vec<i32>,
    /// Inheritable set indicates which capabilities will be inherited by the
    /// current process when running as a root user.
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "3")]
    pub inheritable: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Namespace {
    /// Inode number of the namespace.
    #[prost(uint32, tag = "1")]
    pub inum: u32,
    /// Indicates if namespace belongs to host.
    #[prost(bool, tag = "2")]
    pub is_host: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Namespaces {
    /// Hostname and NIS domain name.
    #[prost(message, optional, tag = "1")]
    pub uts: ::core::option::Option<Namespace>,
    /// System V IPC, POSIX message queues.
    #[prost(message, optional, tag = "2")]
    pub ipc: ::core::option::Option<Namespace>,
    /// Mount points.
    #[prost(message, optional, tag = "3")]
    pub mnt: ::core::option::Option<Namespace>,
    /// Process IDs.
    #[prost(message, optional, tag = "4")]
    pub pid: ::core::option::Option<Namespace>,
    /// Process IDs for children processes.
    #[prost(message, optional, tag = "5")]
    pub pid_for_children: ::core::option::Option<Namespace>,
    /// Network devices, stacks, ports, etc.
    #[prost(message, optional, tag = "6")]
    pub net: ::core::option::Option<Namespace>,
    /// Boot and monotonic clocks.
    #[prost(message, optional, tag = "7")]
    pub time: ::core::option::Option<Namespace>,
    /// Boot and monotonic clocks for children processes.
    #[prost(message, optional, tag = "8")]
    pub time_for_children: ::core::option::Option<Namespace>,
    /// Cgroup root directory.
    #[prost(message, optional, tag = "9")]
    pub cgroup: ::core::option::Option<Namespace>,
    /// User and group IDs.
    #[prost(message, optional, tag = "10")]
    pub user: ::core::option::Option<Namespace>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserNamespace {
    /// Nested level of the user namespace. Init or host user namespace is at level 0.
    #[prost(message, optional, tag = "1")]
    pub level: ::core::option::Option<i32>,
    /// The owner user ID of the namespace
    #[prost(message, optional, tag = "2")]
    pub uid: ::core::option::Option<u32>,
    /// The owner group ID of the namepace.
    #[prost(message, optional, tag = "3")]
    pub gid: ::core::option::Option<u32>,
    /// The user namespace details that include the inode number of the namespace.
    #[prost(message, optional, tag = "4")]
    pub ns: ::core::option::Option<Namespace>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessCredentials {
    /// The real user ID
    #[prost(message, optional, tag = "1")]
    pub uid: ::core::option::Option<u32>,
    /// The real group ID
    #[prost(message, optional, tag = "2")]
    pub gid: ::core::option::Option<u32>,
    /// The effective user ID
    #[prost(message, optional, tag = "3")]
    pub euid: ::core::option::Option<u32>,
    /// The effective group ID
    #[prost(message, optional, tag = "4")]
    pub egid: ::core::option::Option<u32>,
    /// The saved user ID
    #[prost(message, optional, tag = "5")]
    pub suid: ::core::option::Option<u32>,
    /// The saved group ID
    #[prost(message, optional, tag = "6")]
    pub sgid: ::core::option::Option<u32>,
    /// the filesystem user ID
    #[prost(message, optional, tag = "7")]
    pub fsuid: ::core::option::Option<u32>,
    /// The filesystem group ID
    #[prost(message, optional, tag = "8")]
    pub fsgid: ::core::option::Option<u32>,
    /// Secure management flags
    #[prost(enumeration = "SecureBitsType", repeated, tag = "9")]
    pub securebits: ::prost::alloc::vec::Vec<i32>,
    /// Set of capabilities that define the permissions the process can execute with.
    #[prost(message, optional, tag = "10")]
    pub caps: ::core::option::Option<Capabilities>,
    /// User namespace where the UIDs, GIDs and capabilities are relative to.
    #[prost(message, optional, tag = "11")]
    pub user_ns: ::core::option::Option<UserNamespace>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InodeProperties {
    /// The inode number
    #[prost(uint64, tag = "1")]
    pub number: u64,
    /// The inode links on the file system. If zero means the file is only in memory
    #[prost(message, optional, tag = "2")]
    pub links: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileProperties {
    /// Inode of the file
    #[prost(message, optional, tag = "1")]
    pub inode: ::core::option::Option<InodeProperties>,
    /// Path of the file
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinaryProperties {
    /// If set then this is the set user ID used for execution
    #[prost(message, optional, tag = "1")]
    pub setuid: ::core::option::Option<u32>,
    /// If set then this is the set group ID used for execution
    #[prost(message, optional, tag = "2")]
    pub setgid: ::core::option::Option<u32>,
    /// The reasons why this binary execution changed privileges. Usually this happens when the process executes
    /// a binary with the set-user-ID to root or file capability sets.
    /// The final granted privileges can be listed inside the `process_credentials` or capabilities fields part of of the `process` object.
    #[prost(enumeration = "ProcessPrivilegesChanged", repeated, tag = "3")]
    pub privileges_changed: ::prost::alloc::vec::Vec<i32>,
    /// File properties in case the executed binary is:
    /// 1. An anonymous shared memory file <https://man7.org/linux/man-pages/man7/shm_overview.7.html.>
    /// 2. An anonymous file obtained with memfd API <https://man7.org/linux/man-pages/man2/memfd_create.2.html.>
    /// 3. Or it was deleted from the file system.
    #[prost(message, optional, tag = "4")]
    pub file: ::core::option::Option<FileProperties>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    /// Exec ID uniquely identifies the process over time across all the nodes in the cluster.
    #[prost(string, tag = "1")]
    pub exec_id: ::prost::alloc::string::String,
    /// Process identifier from host PID namespace.
    #[prost(message, optional, tag = "2")]
    pub pid: ::core::option::Option<u32>,
    /// User identifier associated with the process.
    #[prost(message, optional, tag = "3")]
    pub uid: ::core::option::Option<u32>,
    /// Current working directory of the process.
    #[prost(string, tag = "4")]
    pub cwd: ::prost::alloc::string::String,
    /// Absolute path of the executed binary.
    #[prost(string, tag = "5")]
    pub binary: ::prost::alloc::string::String,
    /// Arguments passed to the binary at execution.
    #[prost(string, tag = "6")]
    pub arguments: ::prost::alloc::string::String,
    /// Flags are for debugging purposes only and should not be considered a
    /// reliable source of information. They hold various information about
    /// which syscalls generated events, use of internal Tetragon buffers,
    /// errors and more.
    /// - `execve` This event is generated by an execve syscall for a new
    /// process. See procFs for the other option. A correctly formatted event
    /// should either set execve or procFS (described next).
    /// - `procFS` This event is generated from a proc interface. This happens
    /// at Tetragon init when existing processes are being loaded into Tetragon
    /// event buffer. All events should have either execve or procFS set.
    /// - `truncFilename` Indicates a truncated processes filename because the
    /// buffer size is too small to contain the process filename. Consider
    /// increasing buffer size to avoid this.
    /// - `truncArgs` Indicates truncated the processes arguments because the
    /// buffer size was too small to contain all exec args. Consider increasing
    /// buffer size to avoid this.
    /// - `taskWalk` Primarily useful for debugging. Indicates a walked process
    /// hierarchy to find a parent process in the Tetragon buffer. This may
    /// happen when we did not receive an exec event for the immediate parent of
    /// a process. Typically means we are looking at a fork that in turn did
    /// another fork we don't currently track fork events exactly and instead
    /// push an event with the original parent exec data. This flag can provide
    /// this insight into the event if needed.
    /// - `miss` An error flag indicating we could not find parent info in the
    /// Tetragon event buffer. If this is set it should be reported to Tetragon
    /// developers for debugging. Tetragon will do its best to recover
    /// information about the process from available kernel data structures
    /// instead of using cached info in this case. However, args will not be
    /// available.
    /// - `needsAUID` An internal flag for Tetragon to indicate the audit has
    /// not yet been resolved. The BPF hooks look at this flag to determine if
    /// probing the audit system is necessary.
    /// - `errorFilename` An error flag indicating an error happened while
    /// reading the filename. If this is set it should be reported to Tetragon
    /// developers for debugging.
    /// - `errorArgs` An error flag indicating an error happened while reading
    /// the process args. If this is set it should be reported to Tetragon
    /// developers for debugging
    /// - `needsCWD` An internal flag for Tetragon to indicate the current
    /// working directory has not yet been resolved. The Tetragon hooks look at
    /// this flag to determine if probing the CWD is necessary.
    /// - `noCWDSupport` Indicates that CWD is removed from the event because
    /// the buffer size is too small. Consider increasing buffer size to avoid
    /// this.
    /// - `rootCWD` Indicates that CWD is the root directory. This is necessary
    /// to inform readers the CWD is not in the event buffer and is '/' instead.
    /// - `errorCWD` An error flag indicating an error occurred while reading
    /// the CWD of a process. If this is set it should be reported to Tetragon
    /// developers for debugging.
    /// - `clone` Indicates the process issued a clone before exec*. This is the
    /// general flow to exec* a new process, however its possible to replace the
    /// current process with a new process by doing an exec* without a clone. In
    /// this case the flag will be omitted and the same PID will be used by the
    /// kernel for both the old process and the newly exec'd process.
    #[prost(string, tag = "7")]
    pub flags: ::prost::alloc::string::String,
    /// Start time of the execution.
    #[prost(message, optional, tag = "8")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Audit user ID, this ID is assigned to a user upon login and is inherited
    /// by every process even when the user's identity changes. For example, by
    /// switching user accounts with su - john.
    #[prost(message, optional, tag = "9")]
    pub auid: ::core::option::Option<u32>,
    /// Information about the the Kubernetes Pod where the event originated.
    #[prost(message, optional, tag = "10")]
    pub pod: ::core::option::Option<Pod>,
    /// The 15 first digits of the container ID.
    #[prost(string, tag = "11")]
    pub docker: ::prost::alloc::string::String,
    /// Exec ID of the parent process.
    #[prost(string, tag = "12")]
    pub parent_exec_id: ::prost::alloc::string::String,
    /// Reference counter from the Tetragon process cache.
    #[prost(uint32, tag = "13")]
    pub refcnt: u32,
    /// Set of capabilities that define the permissions the process can execute with.
    #[prost(message, optional, tag = "14")]
    pub cap: ::core::option::Option<Capabilities>,
    /// Linux namespaces of the process, disabled by default, can be enabled by
    /// the `--enable-process-ns` flag.
    #[prost(message, optional, tag = "15")]
    pub ns: ::core::option::Option<Namespaces>,
    /// Thread ID, note that for the thread group leader, tid is equal to pid.
    #[prost(message, optional, tag = "16")]
    pub tid: ::core::option::Option<u32>,
    /// Process credentials
    #[prost(message, optional, tag = "17")]
    pub process_credentials: ::core::option::Option<ProcessCredentials>,
    /// Executed binary properties. This field is only available on ProcessExec events.
    #[prost(message, optional, tag = "18")]
    pub binary_properties: ::core::option::Option<BinaryProperties>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessExec {
    /// Process that triggered the exec.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Ancestors of the process beyond the immediate parent.
    #[prost(message, repeated, tag = "3")]
    pub ancestors: ::prost::alloc::vec::Vec<Process>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessExit {
    /// Process that triggered the exit.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Signal that the process received when it exited, for example SIGKILL or
    /// SIGTERM (list all signal names with `kill -l`). If there is no signal
    /// handler implemented for a specific process, we report the exit status
    /// code that can be found in the status field.
    #[prost(string, tag = "3")]
    pub signal: ::prost::alloc::string::String,
    /// Status code on process exit. For example, the status code can indicate
    /// if an error was encountered or the program exited successfully.
    #[prost(uint32, tag = "4")]
    pub status: u32,
    /// Date and time of the event.
    #[prost(message, optional, tag = "5")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeSock {
    #[prost(string, tag = "1")]
    pub family: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub mark: u32,
    #[prost(uint32, tag = "5")]
    pub priority: u32,
    #[prost(string, tag = "6")]
    pub saddr: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub daddr: ::prost::alloc::string::String,
    #[prost(uint32, tag = "8")]
    pub sport: u32,
    #[prost(uint32, tag = "9")]
    pub dport: u32,
    #[prost(uint64, tag = "10")]
    pub cookie: u64,
    #[prost(string, tag = "11")]
    pub state: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeSkb {
    #[prost(uint32, tag = "1")]
    pub hash: u32,
    #[prost(uint32, tag = "2")]
    pub len: u32,
    #[prost(uint32, tag = "3")]
    pub priority: u32,
    #[prost(uint32, tag = "4")]
    pub mark: u32,
    #[prost(string, tag = "5")]
    pub saddr: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub daddr: ::prost::alloc::string::String,
    #[prost(uint32, tag = "7")]
    pub sport: u32,
    #[prost(uint32, tag = "8")]
    pub dport: u32,
    #[prost(uint32, tag = "9")]
    pub proto: u32,
    #[prost(uint32, tag = "10")]
    pub sec_path_len: u32,
    #[prost(uint32, tag = "11")]
    pub sec_path_olen: u32,
    #[prost(string, tag = "12")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub family: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobePath {
    #[prost(string, tag = "1")]
    pub mount: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub flags: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeFile {
    #[prost(string, tag = "1")]
    pub mount: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub flags: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeTruncatedBytes {
    #[prost(bytes = "vec", tag = "1")]
    pub bytes_arg: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub orig_size: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeCred {
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "1")]
    pub permitted: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "2")]
    pub effective: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "CapabilitiesType", repeated, tag = "3")]
    pub inheritable: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeLinuxBinprm {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeCapability {
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<i32>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KprobeUserNamespace {
    #[prost(message, optional, tag = "1")]
    pub level: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub owner: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub group: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub ns: ::core::option::Option<Namespace>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeBpfAttr {
    #[prost(string, tag = "1")]
    pub prog_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub insn_cnt: u32,
    #[prost(string, tag = "3")]
    pub prog_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobePerfEvent {
    #[prost(string, tag = "1")]
    pub kprobe_func: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub config: u64,
    #[prost(uint64, tag = "4")]
    pub probe_offset: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeBpfMap {
    #[prost(string, tag = "1")]
    pub map_type: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub key_size: u32,
    #[prost(uint32, tag = "3")]
    pub value_size: u32,
    #[prost(uint32, tag = "4")]
    pub max_entries: u32,
    #[prost(string, tag = "5")]
    pub map_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KprobeArgument {
    #[prost(string, tag = "18")]
    pub label: ::prost::alloc::string::String,
    #[prost(
        oneof = "kprobe_argument::Arg",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26"
    )]
    pub arg: ::core::option::Option<kprobe_argument::Arg>,
}
/// Nested message and enum types in `KprobeArgument`.
pub mod kprobe_argument {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Arg {
        #[prost(string, tag = "1")]
        StringArg(::prost::alloc::string::String),
        #[prost(int32, tag = "2")]
        IntArg(i32),
        #[prost(message, tag = "3")]
        SkbArg(super::KprobeSkb),
        #[prost(uint64, tag = "4")]
        SizeArg(u64),
        #[prost(bytes, tag = "5")]
        BytesArg(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "6")]
        PathArg(super::KprobePath),
        #[prost(message, tag = "7")]
        FileArg(super::KprobeFile),
        #[prost(message, tag = "8")]
        TruncatedBytesArg(super::KprobeTruncatedBytes),
        #[prost(message, tag = "9")]
        SockArg(super::KprobeSock),
        #[prost(message, tag = "10")]
        CredArg(super::KprobeCred),
        #[prost(int64, tag = "11")]
        LongArg(i64),
        #[prost(message, tag = "12")]
        BpfAttrArg(super::KprobeBpfAttr),
        #[prost(message, tag = "13")]
        PerfEventArg(super::KprobePerfEvent),
        #[prost(message, tag = "14")]
        BpfMapArg(super::KprobeBpfMap),
        #[prost(uint32, tag = "15")]
        UintArg(u32),
        #[prost(message, tag = "16")]
        UserNamespaceArg(super::KprobeUserNamespace),
        #[prost(message, tag = "17")]
        CapabilityArg(super::KprobeCapability),
        #[prost(message, tag = "19")]
        ProcessCredentialsArg(super::ProcessCredentials),
        #[prost(message, tag = "20")]
        UserNsArg(super::UserNamespace),
        #[prost(message, tag = "21")]
        ModuleArg(super::KernelModule),
        /// Capabilities in hexadecimal format.
        #[prost(string, tag = "22")]
        KernelCapTArg(::prost::alloc::string::String),
        /// Capabilities inherited by a forked process in hexadecimal format.
        #[prost(string, tag = "23")]
        CapInheritableArg(::prost::alloc::string::String),
        /// Capabilities that are currently permitted in hexadecimal format.
        #[prost(string, tag = "24")]
        CapPermittedArg(::prost::alloc::string::String),
        /// Capabilities that are actually used in hexadecimal format.
        #[prost(string, tag = "25")]
        CapEffectiveArg(::prost::alloc::string::String),
        #[prost(message, tag = "26")]
        LinuxBinprmArg(super::KprobeLinuxBinprm),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessKprobe {
    /// Process that triggered the kprobe.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Symbol on which the kprobe was attached.
    #[prost(string, tag = "3")]
    pub function_name: ::prost::alloc::string::String,
    /// Arguments definition of the observed kprobe.
    #[prost(message, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Return value definition of the observed kprobe.
    #[prost(message, optional, tag = "5")]
    pub r#return: ::core::option::Option<KprobeArgument>,
    /// Action performed when the kprobe matched.
    #[prost(enumeration = "KprobeAction", tag = "6")]
    pub action: i32,
    /// Kernel stack trace to the call.
    #[prost(message, repeated, tag = "7")]
    pub stack_trace: ::prost::alloc::vec::Vec<StackTraceEntry>,
    /// Name of the Tracing Policy that created that kprobe.
    #[prost(string, tag = "8")]
    pub policy_name: ::prost::alloc::string::String,
    /// Action performed when the return kprobe executed.
    #[prost(enumeration = "KprobeAction", tag = "9")]
    pub return_action: i32,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "10")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessTracepoint {
    /// Process that triggered the tracepoint.
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    /// Immediate parent of the process.
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    /// Subsystem of the tracepoint.
    #[prost(string, tag = "4")]
    pub subsys: ::prost::alloc::string::String,
    /// Event of the subsystem.
    #[prost(string, tag = "5")]
    pub event: ::prost::alloc::string::String,
    /// Arguments definition of the observed tracepoint.
    /// TODO: once we implement all we want, rename KprobeArgument to GenericArgument
    #[prost(message, repeated, tag = "6")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
    /// Name of the policy that created that tracepoint.
    #[prost(string, tag = "7")]
    pub policy_name: ::prost::alloc::string::String,
    /// Action performed when the tracepoint matched.
    #[prost(enumeration = "KprobeAction", tag = "8")]
    pub action: i32,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "9")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessUprobe {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(message, optional, tag = "2")]
    pub parent: ::core::option::Option<Process>,
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub symbol: ::prost::alloc::string::String,
    /// Name of the policy that created that uprobe.
    #[prost(string, tag = "5")]
    pub policy_name: ::prost::alloc::string::String,
    /// Short message of the Tracing Policy to inform users what is going on.
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    /// Arguments definition of the observed uprobe.
    #[prost(message, repeated, tag = "7")]
    pub args: ::prost::alloc::vec::Vec<KprobeArgument>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelModule {
    /// Kernel module name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If true the module signature was verified successfully. Depends on kernels compiled with
    /// CONFIG_MODULE_SIG option, for details please read: <https://www.kernel.org/doc/Documentation/admin-guide/module-signing.rst>
    #[prost(message, optional, tag = "2")]
    pub signature_ok: ::core::option::Option<bool>,
    /// The module tainted flags that will be applied on the kernel. For further details please read: <https://docs.kernel.org/admin-guide/tainted-kernels.html>
    #[prost(enumeration = "TaintedBitsType", repeated, tag = "3")]
    pub tainted: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Test {
    #[prost(uint64, tag = "1")]
    pub arg0: u64,
    #[prost(uint64, tag = "2")]
    pub arg1: u64,
    #[prost(uint64, tag = "3")]
    pub arg2: u64,
    #[prost(uint64, tag = "4")]
    pub arg3: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthStatusRequest {
    #[prost(enumeration = "HealthStatusType", repeated, tag = "1")]
    pub event_set: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthStatus {
    #[prost(enumeration = "HealthStatusType", tag = "1")]
    pub event: i32,
    #[prost(enumeration = "HealthStatusResult", tag = "2")]
    pub status: i32,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub health_status: ::prost::alloc::vec::Vec<HealthStatus>,
}
/// loader sensor event triggered for loaded binary/library
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessLoader {
    #[prost(message, optional, tag = "1")]
    pub process: ::core::option::Option<Process>,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub buildid: ::prost::alloc::vec::Vec<u8>,
}
/// RuntimeHookRequest synchronously propagates information to the agent about run-time state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeHookRequest {
    #[prost(oneof = "runtime_hook_request::Event", tags = "1")]
    pub event: ::core::option::Option<runtime_hook_request::Event>,
}
/// Nested message and enum types in `RuntimeHookRequest`.
pub mod runtime_hook_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        CreateContainer(super::CreateContainer),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RuntimeHookResponse {}
/// CreateContainer informs the agent that a container was created
/// This is intented to be used by OCI hooks (but not limited to them) and corresponds to the
/// CreateContainer hook:
/// <https://github.com/opencontainers/runtime-spec/blob/main/config.md#createcontainer-hooks.>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContainer {
    /// cgroupsPath is the cgroups path for the container. The path is expected to be relative to the
    /// cgroups mountpoint. See: <https://github.com/opencontainers/runtime-spec/blob/58ec43f9fc39e0db229b653ae98295bfde74aeab/specs-go/config.go#L174>
    #[prost(string, tag = "1")]
    pub cgroups_path: ::prost::alloc::string::String,
    /// rootDir is the absolute path of the root directory of the container.
    /// See: <https://github.com/opencontainers/runtime-spec/blob/main/specs-go/config.go#L174>
    #[prost(string, tag = "2")]
    pub root_dir: ::prost::alloc::string::String,
    /// annotations are the run-time annotations for the container
    /// see <https://github.com/opencontainers/runtime-spec/blob/main/config.md#annotations>
    #[prost(map = "string, string", tag = "3")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTraceEntry {
    /// address is the kernel function address.
    #[prost(uint64, tag = "1")]
    pub address: u64,
    /// offset is the offset into the native instructions for the function.
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    /// symbol is the symbol name of the function.
    #[prost(string, tag = "3")]
    pub symbol: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KprobeAction {
    /// Unknown action
    Unknown = 0,
    /// Post action creates an event (default action).
    Post = 1,
    /// Post action creates a mapping between file descriptors and file names.
    Followfd = 2,
    /// Sigkill action synchronously terminates the process.
    Sigkill = 3,
    /// Post action removes a mapping between file descriptors and file names.
    Unfollowfd = 4,
    /// Override action modifies the return value of the call.
    Override = 5,
    /// Post action dupplicates a mapping between file descriptors and file
    /// names.
    Copyfd = 6,
    /// GetURL action issue an HTTP Get request against an URL from userspace.
    Geturl = 7,
    /// GetURL action issue a DNS lookup against an URL from userspace.
    Dnslookup = 8,
    /// NoPost action suppresses the transmission of the event to userspace.
    Nopost = 9,
    /// Signal action sends specified signal to the process.
    Signal = 10,
    /// TrackSock action tracks socket.
    Tracksock = 11,
    /// UntrackSock action un-tracks socket.
    Untracksock = 12,
    /// NotifyKiller action notifies killer sensor.
    Notifykiller = 13,
}
impl KprobeAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "KPROBE_ACTION_UNKNOWN",
            Self::Post => "KPROBE_ACTION_POST",
            Self::Followfd => "KPROBE_ACTION_FOLLOWFD",
            Self::Sigkill => "KPROBE_ACTION_SIGKILL",
            Self::Unfollowfd => "KPROBE_ACTION_UNFOLLOWFD",
            Self::Override => "KPROBE_ACTION_OVERRIDE",
            Self::Copyfd => "KPROBE_ACTION_COPYFD",
            Self::Geturl => "KPROBE_ACTION_GETURL",
            Self::Dnslookup => "KPROBE_ACTION_DNSLOOKUP",
            Self::Nopost => "KPROBE_ACTION_NOPOST",
            Self::Signal => "KPROBE_ACTION_SIGNAL",
            Self::Tracksock => "KPROBE_ACTION_TRACKSOCK",
            Self::Untracksock => "KPROBE_ACTION_UNTRACKSOCK",
            Self::Notifykiller => "KPROBE_ACTION_NOTIFYKILLER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KPROBE_ACTION_UNKNOWN" => Some(Self::Unknown),
            "KPROBE_ACTION_POST" => Some(Self::Post),
            "KPROBE_ACTION_FOLLOWFD" => Some(Self::Followfd),
            "KPROBE_ACTION_SIGKILL" => Some(Self::Sigkill),
            "KPROBE_ACTION_UNFOLLOWFD" => Some(Self::Unfollowfd),
            "KPROBE_ACTION_OVERRIDE" => Some(Self::Override),
            "KPROBE_ACTION_COPYFD" => Some(Self::Copyfd),
            "KPROBE_ACTION_GETURL" => Some(Self::Geturl),
            "KPROBE_ACTION_DNSLOOKUP" => Some(Self::Dnslookup),
            "KPROBE_ACTION_NOPOST" => Some(Self::Nopost),
            "KPROBE_ACTION_SIGNAL" => Some(Self::Signal),
            "KPROBE_ACTION_TRACKSOCK" => Some(Self::Tracksock),
            "KPROBE_ACTION_UNTRACKSOCK" => Some(Self::Untracksock),
            "KPROBE_ACTION_NOTIFYKILLER" => Some(Self::Notifykiller),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatusType {
    Undef = 0,
    Status = 1,
}
impl HealthStatusType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undef => "HEALTH_STATUS_TYPE_UNDEF",
            Self::Status => "HEALTH_STATUS_TYPE_STATUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_TYPE_UNDEF" => Some(Self::Undef),
            "HEALTH_STATUS_TYPE_STATUS" => Some(Self::Status),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatusResult {
    HealthStatusUndef = 0,
    HealthStatusRunning = 1,
    HealthStatusStopped = 2,
    HealthStatusError = 3,
}
impl HealthStatusResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HealthStatusUndef => "HEALTH_STATUS_UNDEF",
            Self::HealthStatusRunning => "HEALTH_STATUS_RUNNING",
            Self::HealthStatusStopped => "HEALTH_STATUS_STOPPED",
            Self::HealthStatusError => "HEALTH_STATUS_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNDEF" => Some(Self::HealthStatusUndef),
            "HEALTH_STATUS_RUNNING" => Some(Self::HealthStatusRunning),
            "HEALTH_STATUS_STOPPED" => Some(Self::HealthStatusStopped),
            "HEALTH_STATUS_ERROR" => Some(Self::HealthStatusError),
            _ => None,
        }
    }
}
/// Tainted bits to indicate if the kernel was tainted. For further details: <https://docs.kernel.org/admin-guide/tainted-kernels.html>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaintedBitsType {
    TaintUnset = 0,
    /// A proprietary module was loaded.
    TaintProprietaryModule = 1,
    /// A module was force loaded.
    TaintForcedModule = 2,
    /// A module was force unloaded.
    TaintForcedUnloadModule = 4,
    /// A staging driver was loaded.
    TaintStagedModule = 1024,
    /// An out of tree module was loaded.
    TaintOutOfTreeModule = 4096,
    /// An unsigned module was loaded. Supported only on kernels built with CONFIG_MODULE_SIG option.
    TaintUnsignedModule = 8192,
    /// The kernel has been live patched.
    TaintKernelLivePatchModule = 32768,
    /// Loading a test module.
    TaintTestModule = 262144,
}
impl TaintedBitsType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TaintUnset => "TAINT_UNSET",
            Self::TaintProprietaryModule => "TAINT_PROPRIETARY_MODULE",
            Self::TaintForcedModule => "TAINT_FORCED_MODULE",
            Self::TaintForcedUnloadModule => "TAINT_FORCED_UNLOAD_MODULE",
            Self::TaintStagedModule => "TAINT_STAGED_MODULE",
            Self::TaintOutOfTreeModule => "TAINT_OUT_OF_TREE_MODULE",
            Self::TaintUnsignedModule => "TAINT_UNSIGNED_MODULE",
            Self::TaintKernelLivePatchModule => "TAINT_KERNEL_LIVE_PATCH_MODULE",
            Self::TaintTestModule => "TAINT_TEST_MODULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAINT_UNSET" => Some(Self::TaintUnset),
            "TAINT_PROPRIETARY_MODULE" => Some(Self::TaintProprietaryModule),
            "TAINT_FORCED_MODULE" => Some(Self::TaintForcedModule),
            "TAINT_FORCED_UNLOAD_MODULE" => Some(Self::TaintForcedUnloadModule),
            "TAINT_STAGED_MODULE" => Some(Self::TaintStagedModule),
            "TAINT_OUT_OF_TREE_MODULE" => Some(Self::TaintOutOfTreeModule),
            "TAINT_UNSIGNED_MODULE" => Some(Self::TaintUnsignedModule),
            "TAINT_KERNEL_LIVE_PATCH_MODULE" => Some(Self::TaintKernelLivePatchModule),
            "TAINT_TEST_MODULE" => Some(Self::TaintTestModule),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Filter {
    #[prost(string, repeated, tag = "1")]
    pub binary_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub namespace: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub health_check: ::core::option::Option<bool>,
    #[prost(uint32, repeated, tag = "4")]
    pub pid: ::prost::alloc::vec::Vec<u32>,
    /// Filter by the PID of a process and any of its descendants. Note that this filter is
    /// intended for testing and development purposes only and should not be used in
    /// production. In particular, PID cycling in the OS over longer periods of time may
    /// cause unexpected events to pass this filter.
    #[prost(uint32, repeated, tag = "5")]
    pub pid_set: ::prost::alloc::vec::Vec<u32>,
    #[prost(enumeration = "EventType", repeated, tag = "6")]
    pub event_set: ::prost::alloc::vec::Vec<i32>,
    /// Filter by process.pod.name field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "7")]
    pub pod_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter by process.arguments field using RE2 regular expression syntax:
    /// <https://github.com/google/re2/wiki/Syntax>
    #[prost(string, repeated, tag = "8")]
    pub arguments_regex: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter events by pod labels using Kubernetes label selector syntax:
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors>
    /// Note that this filter never matches events without the pod field (i.e.
    /// host process events).
    #[prost(string, repeated, tag = "9")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Filter events by tracing policy names
    #[prost(string, repeated, tag = "10")]
    pub policy_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldFilter {
    /// Event types to filter or undefined to filter over all event types.
    #[prost(enumeration = "EventType", repeated, tag = "1")]
    pub event_set: ::prost::alloc::vec::Vec<i32>,
    /// Fields to include or exclude.
    #[prost(message, optional, tag = "2")]
    pub fields: ::core::option::Option<::prost_types::FieldMask>,
    /// Whether to include or exclude fields.
    #[prost(enumeration = "FieldFilterAction", tag = "3")]
    pub action: i32,
    /// Whether or not the event set filter should be inverted.
    #[prost(message, optional, tag = "4")]
    pub invert_event_set: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsRequest {
    /// allow_list specifies a list of filters to apply to only return certain
    /// events. If multiple filters are specified, at least one of them has to
    /// match for an event to be included in the results.
    #[prost(message, repeated, tag = "1")]
    pub allow_list: ::prost::alloc::vec::Vec<Filter>,
    /// deny_list specifies a list of filters to apply to exclude certain events
    /// from the results. If multiple filters are specified, at least one of
    /// them has to match for an event to be excluded.
    /// If both allow_list and deny_list are specified, the results contain the
    /// set difference allow_list - deny_list.
    #[prost(message, repeated, tag = "2")]
    pub deny_list: ::prost::alloc::vec::Vec<Filter>,
    /// aggregation_options configures aggregation options for this request.
    /// If this field is not set, responses will not be aggregated.
    /// Note that currently only process_accept and process_connect events are
    /// aggregated. Other events remain unaggregated.
    #[prost(message, optional, tag = "3")]
    pub aggregation_options: ::core::option::Option<AggregationOptions>,
    /// Fields to include or exclude for events in the GetEventsResponse. Omitting this
    /// field implies that all fields will be included. Exclusion always takes precedence
    /// over inclusion in the case of conflicts.
    #[prost(message, repeated, tag = "4")]
    pub field_filters: ::prost::alloc::vec::Vec<FieldFilter>,
}
/// AggregationOptions defines configuration options for aggregating events.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AggregationOptions {
    /// Aggregation window size. Defaults to 15 seconds if this field is not set.
    #[prost(message, optional, tag = "1")]
    pub window_size: ::core::option::Option<::prost_types::Duration>,
    /// Size of the buffer for the aggregator to receive incoming events. If the
    /// buffer becomes full, the aggregator will log a warning and start dropping
    /// incoming events.
    #[prost(uint64, tag = "2")]
    pub channel_buffer_size: u64,
}
/// AggregationInfo contains information about aggregation results.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AggregationInfo {
    /// Total count of events in this aggregation time window.
    #[prost(uint64, tag = "1")]
    pub count: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RateLimitInfo {
    #[prost(uint64, tag = "1")]
    pub number_of_dropped_process_events: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsResponse {
    /// Name of the node where this event was observed.
    #[prost(string, tag = "1000")]
    pub node_name: ::prost::alloc::string::String,
    /// Timestamp at which this event was observed.
    /// For an aggregated response, this field to set to the timestamp at which
    /// the event was observed for the first time in a given aggregation time window.
    #[prost(message, optional, tag = "1001")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// aggregation_info contains information about aggregation results. This field
    /// is set only for aggregated responses.
    #[prost(message, optional, tag = "1002")]
    pub aggregation_info: ::core::option::Option<AggregationInfo>,
    /// The type-specific fields of an event.
    ///
    /// NOTE: Numbers must stay in sync with enum EventType.
    #[prost(
        oneof = "get_events_response::Event",
        tags = "1, 5, 9, 10, 11, 12, 40000, 40001"
    )]
    pub event: ::core::option::Option<get_events_response::Event>,
}
/// Nested message and enum types in `GetEventsResponse`.
pub mod get_events_response {
    /// The type-specific fields of an event.
    ///
    /// NOTE: Numbers must stay in sync with enum EventType.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        /// ProcessExec event includes information about the execution of
        /// binaries and other related process metadata.
        #[prost(message, tag = "1")]
        ProcessExec(super::ProcessExec),
        /// ProcessExit event indicates how and when a process terminates.
        #[prost(message, tag = "5")]
        ProcessExit(super::ProcessExit),
        /// ProcessKprobe event contains information about the pre-defined
        /// functions and the process that invoked them.
        #[prost(message, tag = "9")]
        ProcessKprobe(super::ProcessKprobe),
        /// ProcessTracepoint contains information about the pre-defined
        /// tracepoint and the process that invoked them.
        #[prost(message, tag = "10")]
        ProcessTracepoint(super::ProcessTracepoint),
        #[prost(message, tag = "11")]
        ProcessLoader(super::ProcessLoader),
        #[prost(message, tag = "12")]
        ProcessUprobe(super::ProcessUprobe),
        #[prost(message, tag = "40000")]
        Test(super::Test),
        #[prost(message, tag = "40001")]
        RateLimitInfo(super::RateLimitInfo),
    }
}
/// Represents the type of a Tetragon event.
///
/// NOTE: EventType constants must be in sync with the numbers used in the
/// GetEventsResponse event oneof.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    Undef = 0,
    ProcessExec = 1,
    ProcessExit = 5,
    ProcessKprobe = 9,
    ProcessTracepoint = 10,
    ProcessLoader = 11,
    ProcessUprobe = 12,
    Test = 40000,
    RateLimitInfo = 40001,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Undef => "UNDEF",
            Self::ProcessExec => "PROCESS_EXEC",
            Self::ProcessExit => "PROCESS_EXIT",
            Self::ProcessKprobe => "PROCESS_KPROBE",
            Self::ProcessTracepoint => "PROCESS_TRACEPOINT",
            Self::ProcessLoader => "PROCESS_LOADER",
            Self::ProcessUprobe => "PROCESS_UPROBE",
            Self::Test => "TEST",
            Self::RateLimitInfo => "RATE_LIMIT_INFO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNDEF" => Some(Self::Undef),
            "PROCESS_EXEC" => Some(Self::ProcessExec),
            "PROCESS_EXIT" => Some(Self::ProcessExit),
            "PROCESS_KPROBE" => Some(Self::ProcessKprobe),
            "PROCESS_TRACEPOINT" => Some(Self::ProcessTracepoint),
            "PROCESS_LOADER" => Some(Self::ProcessLoader),
            "PROCESS_UPROBE" => Some(Self::ProcessUprobe),
            "TEST" => Some(Self::Test),
            "RATE_LIMIT_INFO" => Some(Self::RateLimitInfo),
            _ => None,
        }
    }
}
/// Determines the behavior of a field filter
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldFilterAction {
    Include = 0,
    Exclude = 1,
}
impl FieldFilterAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Include => "INCLUDE",
            Self::Exclude => "EXCLUDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INCLUDE" => Some(Self::Include),
            "EXCLUDE" => Some(Self::Exclude),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackAddress {
    #[prost(uint64, tag = "1")]
    pub address: u64,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTrace {
    #[prost(message, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<StackAddress>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTraceLabel {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub count: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTraceNode {
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<StackAddress>,
    #[prost(uint64, tag = "2")]
    pub count: u64,
    #[prost(message, repeated, tag = "3")]
    pub labels: ::prost::alloc::vec::Vec<StackTraceLabel>,
    #[prost(message, repeated, tag = "4")]
    pub children: ::prost::alloc::vec::Vec<StackTraceNode>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListSensorsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorStatus {
    /// name is the name of the sensor
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// enabled marks whether the sensor is enabled
    #[prost(bool, tag = "2")]
    pub enabled: bool,
    /// collection is the collection the sensor belongs to (typically a tracing policy)
    #[prost(string, tag = "3")]
    pub collection: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSensorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub sensors: ::prost::alloc::vec::Vec<SensorStatus>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListTracingPoliciesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracingPolicyStatus {
    /// id is the id of the policy
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// name is the name of the policy
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// namespace is the namespace of the policy (or empty of the policy is global)
    #[prost(string, tag = "3")]
    pub namespace: ::prost::alloc::string::String,
    /// info is additional information about the policy
    #[prost(string, tag = "4")]
    pub info: ::prost::alloc::string::String,
    /// sensors loaded in the scope of this policy
    #[prost(string, repeated, tag = "5")]
    pub sensors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// indicating if the policy is enabled. Deprecated: use 'state' instead.
    #[deprecated]
    #[prost(bool, tag = "6")]
    pub enabled: bool,
    /// filter ID of the policy used for k8s filtering
    #[prost(uint64, tag = "7")]
    pub filter_id: u64,
    /// potential error of the policy
    #[prost(string, tag = "8")]
    pub error: ::prost::alloc::string::String,
    /// current state of the tracing policy
    #[prost(enumeration = "TracingPolicyState", tag = "9")]
    pub state: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTracingPoliciesResponse {
    #[prost(message, repeated, tag = "1")]
    pub policies: ::prost::alloc::vec::Vec<TracingPolicyStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub yaml: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableTracingPolicyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableTracingPolicyResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveSensorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveSensorResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableSensorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnableSensorResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableSensorRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisableSensorResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStackTraceTreeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStackTraceTreeResponse {
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<StackTraceNode>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TracingPolicyState {
    /// unknown state
    TpStateUnknown = 0,
    /// loaded and enabled
    TpStateEnabled = 1,
    /// loaded but disabled
    TpStateDisabled = 2,
    /// failed to load
    TpStateLoadError = 3,
    /// failed during lifetime
    TpStateError = 4,
}
impl TracingPolicyState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TpStateUnknown => "TP_STATE_UNKNOWN",
            Self::TpStateEnabled => "TP_STATE_ENABLED",
            Self::TpStateDisabled => "TP_STATE_DISABLED",
            Self::TpStateLoadError => "TP_STATE_LOAD_ERROR",
            Self::TpStateError => "TP_STATE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TP_STATE_UNKNOWN" => Some(Self::TpStateUnknown),
            "TP_STATE_ENABLED" => Some(Self::TpStateEnabled),
            "TP_STATE_DISABLED" => Some(Self::TpStateDisabled),
            "TP_STATE_LOAD_ERROR" => Some(Self::TpStateLoadError),
            "TP_STATE_ERROR" => Some(Self::TpStateError),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod fine_guidance_sensors_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FineGuidanceSensorsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FineGuidanceSensorsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FineGuidanceSensorsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FineGuidanceSensorsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FineGuidanceSensorsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_events(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetEventsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetEvents"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHealthStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetHealthStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetHealth"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn add_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::AddTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/AddTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tetragon.FineGuidanceSensors", "AddTracingPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/DeleteTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "DeleteTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn remove_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/RemoveSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "RemoveSensor"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_tracing_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTracingPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTracingPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/ListTracingPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "ListTracingPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn enable_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnableTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/EnableTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "EnableTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn disable_tracing_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableTracingPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisableTracingPolicyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/DisableTracingPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "tetragon.FineGuidanceSensors",
                        "DisableTracingPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_sensors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSensorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSensorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/ListSensors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "ListSensors"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn enable_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EnableSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/EnableSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "EnableSensor"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn disable_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DisableSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/DisableSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tetragon.FineGuidanceSensors", "DisableSensor"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_stack_trace_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStackTraceTreeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetStackTraceTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetStackTraceTree",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("tetragon.FineGuidanceSensors", "GetStackTraceTree"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn runtime_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::RuntimeHookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RuntimeHookResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/tetragon.FineGuidanceSensors/RuntimeHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("tetragon.FineGuidanceSensors", "RuntimeHook"));
            self.inner.unary(req, path, codec).await
        }
    }
}
